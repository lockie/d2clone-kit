#+STARTUP: showall indent hidestars

* Quickstart

d2clone-kit engine requires [[https://liballeg.org][liballegro]] game programming library to function (*unrelated* to Allegro Common Lisp; d2clone-kit supports variety of Common Lisp compilers, including SBCL).

To install liballegro development files, refer to your distribution's package manager; for instance, on Debian derivatives (including Ubuntu and Mint) issue the following command:

#+BEGIN_SRC shell
sudo apt-get install liballegro-acodec5-dev liballegro-audio5-dev \
    liballegro-image5-dev liballegro-dialog5-dev liballegro-ttf5-dev \
    liballegro-physfs5-dev liballegro-video5-dev
#+END_SRC

Now, clone the repo to your [[https://quicklisp.org][Quicklisp]] directory and download resource files:

#+BEGIN_SRC shell
export QUICKLISP_DIR=~/quicklisp  # adjust according to your Quicklisp path
git clone https://gitlab.com/lockie/d2clone-kit $QUICKLISP_DIR/local-projects/d2clone-kit
wget https://gitlab.com/lockie/darkness-looming-the-dawn/-/raw/master/Resources/assets.zip \
    -P $QUICKLISP_DIR/local-projects/d2clone-kit/Resources/
cd $QUICKLISP_DIR/local-projects/d2clone-kit/src/
#+END_SRC

Start your favourite Lisp (or slime/sly) from engine's =src/= subdirectory.
To launch the built-in engine demo using the resources you've downloaded, type in REPL:

#+BEGIN_SRC lisp
(ql:register-local-projects)
(ql:quickload :d2clone-kit)
(d2clone-kit:demo)
#+END_SRC

* Source code walkthrough

d2clone-kit is licensed under the GNU GPL license version 3.

We put all of engine's source code into ~:d2clone-kit~ package.

#+NAME: preamble
#+BEGIN_SRC lisp
;;;; Copyright (C) 2020-2021 Andrew Kravchuk and contributors
;;;;
;;;; This program is free software: you can redistribute it and/or modify
;;;; it under the terms of the GNU General Public License as published by
;;;; the Free Software Foundation, either version 3 of the License, or
;;;; (at your option) any later version.
;;;;
;;;; This program is distributed in the hope that it will be useful,
;;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;;; GNU General Public License for more details.
;;;;
;;;; You should have received a copy of the GNU General Public License
;;;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;;;; WARNING: DO NOT EDIT, AUTO-GENERATED CODE. Edit doc.org instead.

(in-package :d2clone-kit)
#+END_SRC

** Entry point

#+BEGIN_SRC lisp :tangle d2clone-kit.lisp :noweb yes :exports none
<<preamble>>

<<ui-handle-event>>

<<systems-handle-event>>

<<game-loop-1>>
<<game-loop-2>>
<<game-loop-3>>
<<game-loop-4>>
<<game-loop-5>>
<<game-loop-6>>
<<game-loop-7>>

<<callback-globals>>

<<new-game>>

<<game-started-p>>

<<package-version>>

<<run-engine-1>>
<<run-engine-2>>
<<run-engine-3>>
<<run-engine-4>>
<<run-engine-5>>
<<run-engine-6>>
<<run-engine-7>>
<<run-engine-8>>
<<run-engine-9>>

<<start-engine>>

<<demo>>
#+END_SRC

The entry point to the game, should it be ~d2clone-kit:demo~ or other kind of ~main~ function supplied to ~:entry-point~ argument of game's ~asdf:defsystem~, just needs to call ~start-engine~ with appropriate arguments:

#+NAME: demo
#+BEGIN_SRC lisp
(defun demo ()
  "Runs built-in engine demo."
  (start-engine
   "demo"
   ;; TODO : load that from map file!
   ;; TODO : also store initial player position in the file
   ;;  (or some kind of "entrypoint" or "spawnpoint")
   '(((:camera)
      (:coordinate :x 0d0 :y 0d0))
     ((:player)
      (:coordinate :x 0d0 :y 0d0)
      (:sprite :prefab :heroine :layers-initially-toggled (:head :clothes))
      (:character)
      (:hp :current 100d0 :maximum 100d0)
      (:mana :current 100d0 :maximum 100d0)
      (:combat :min-damage 1d0 :max-damage 2d0))
     ((:mob :name "Spiderant")
      (:coordinate :x 2d0 :y 2d0)
      (:sprite :prefab :spiderant :layers-initially-toggled (:body))
      (:character :speed 1d0)
      (:hp :current 15d0 :maximum 15d0)
      (:combat :min-damage 1d0 :max-damage 10d0))
     ;; ((:mob :name "Spiderant")
     ;;  (:coordinate :x 4d0 :y 4d0)
     ;;  (:sprite :prefab :spiderant :layers-initially-toggled (:body))
     ;;  (:character :speed 1d0)
     ;;  (:hp :current 50d0 :maximum 50d0))
     ;; ((:mob :name "Spiderant")
     ;;  (:coordinate :x 3d0 :y 3d0)
     ;;  (:sprite :prefab :spiderant :layers-initially-toggled (:body))
     ;;  (:character :speed 1d0)
     ;;  (:hp :current 50d0 :maximum 50d0))
     ((:coordinate :x 0d0 :y 0d0)
      (:map :prefab :map)))
   nil))
#+END_SRC

** Engine

To start the engine, we'll save the arguments passed to ~start-engine~ to dynamic variables defined above to properly pass it to CFFI callback we'll discuss in a moment:

#+NAME: callback-globals
#+BEGIN_SRC lisp
(defvar *game-name*)
(defvar *sanitized-game-name*)
(defvar *new-game-object-specs*)
(defvar *config-options*)
(defvar *table-indices*)
#+END_SRC

Then we use ~float-features:with-float-traps-masked~ from Shinmera's [[https://shinmera.github.io/float-features][float-features]] library to stop Lisp popping up with floating point errors (like e.g. [[https://en.wikipedia.org/wiki/Arithmetic_underflow][underflow]]) which are usual (and by default ignored) in C world.

Finally, we call [[https://liballeg.org/a5docs/trunk/misc.html#al_run_main][~al:run-main~]] from liballegro with the ~run-engine~ [[https://common-lisp.net/project/cffi/manual/html_node/defcallback.html][CFFI callback]]; this is required in order for the game to be able to run under MacOS with its weird main thread rules.

#+NAME: start-engine
#+BEGIN_SRC lisp
(defunl start-engine (game-name new-game-object-specs table-indices
                                &rest config)
  "Initializes and starts engine to run the game named by GAME-NAME.
NEW-GAME-OBJECT-SPECS is list of game object specifications to be created when
 the new game is started with MAKE-OBJECT. TABLE-INDICES, if non-nil,
 specifies the columns in indices to build from a data tables read from .cdb
 file with BUILD-DATA-TABLES. CONFIG plist is used to override variables read
 from config file.

See MAKE-OBJECT
See BUILD-DATA-TABLES"
  (let ((*game-name* game-name)
        (*sanitized-game-name* (sanitize-filename game-name))
        (*new-game-object-specs* new-game-object-specs)
        (*config-options* config)
        (*table-indices* table-indices))
    (float-features:with-float-traps-masked
        (:divide-by-zero :invalid :inexact :overflow :underflow)
      (al:run-main 0 (cffi:null-pointer) (cffi:callback run-engine)))))
#+END_SRC

~run-engine~ begins with ~with-condition-reporter~ macro:

#+NAME: run-engine-1
#+BEGIN_SRC lisp
(cffi:defcallback run-engine :int ((argc :int) (argv :pointer))
  (declare (ignore argc argv))
  (with-condition-reporter
#+END_SRC

This macro executes a block of code, and if it triggers an unhandled condition, it displays nice GUI dialog with [[https://liballeg.org/a5docs/trunk/native_dialog.html#al_show_native_message_box][~al:show-native-message-box~]] displaying its description and good old "Hey guys" error message. Of course this only happens when you're not running your Lisp under debugger. Also, this macro puts condition description as well as full backtrace to liballegro log.

#+NAME: with-condition-reporter
#+BEGIN_SRC lisp
(defmacro with-condition-reporter (&body body)
  "Executes BODY with generic error handler which puts full error
condition info including backtrace to liballegro log and displays error
messagebox when not in debugger."
  `(handler-bind
       ((error #'(lambda (e)
                   (log-error "~a"
                              (with-output-to-string (s)
                                (uiop:print-condition-backtrace e :stream s)))
                   (unless *debugger-hook*
                     (al:show-native-message-box
                      (cffi:null-pointer) "Hey guys"
                      "We got a big error here :(" (format nil "~a" e)
                      (cffi:null-pointer) :error)))))
     ,@body))
#+END_SRC

So the next thing ~run-engine~ does is determining the *data directory* (something like =~/.local/share/demo/=, where =demo= is the name of the game sans forbidden characters, which is held in ~*sanitized-game-name*~ variable).

#+NAME: run-engine-2
#+BEGIN_SRC lisp
    (let ((data-dir
            (merge-pathnames
             (make-pathname :directory `(:relative ,*sanitized-game-name*))
             (uiop:xdg-data-home))))
      (ensure-directories-exist data-dir)
#+END_SRC

Next, we initialize core liballegro facilities: logging, the library itself, filesystem and configuration subsystems.

#+NAME: run-engine-3
#+BEGIN_SRC lisp
      ;; TODO : ability to set level e.g. by command line variable
      ;;  (it is not possible through config because of "deadlock")
      (init-log data-dir)
      (al:set-app-name *sanitized-game-name*)
      (al:init)
      (log-info "Starting d2clone-kit engine ~a"
                (package-version "v~a" :d2clone-kit))
      (init-fs *sanitized-game-name* data-dir)
      (init-config))

#+END_SRC

Right after logging is initialized, we emit a newborn cry - the very first log line, reporting engine version by using the following nice helper function which tries to get given package version from [[https://common-lisp.net/project/asdf/][ASDF]]:

#+NAME: package-version
#+BEGIN_SRC lisp
(declaim
 (ftype (function (string (or character symbol string)) (or string null))
        package-version))
(defun package-version (format package)
  "Returns the PACKAGE version from asdf formatted according to FORMAT. If the
package does not exist, then retuns NIL."
  (values
   (when-let (package-instance (asdf:find-system package nil))
     (format nil format (slot-value package-instance 'asdf:version)))))
#+END_SRC

Afterwards, we initialize various liballegro addons:

#+NAME: run-engine-4
#+BEGIN_SRC lisp
    ;; TODO : proper recover from those errors (properly finalize)+retry restart
    (unless (al:init-primitives-addon)
      (error "Initializing primitives addon failed"))
    (unless (al:init-image-addon)
      (error "Initializing image addon failed"))
    (al:init-font-addon)
    (unless (al:init-ttf-addon)
      (error "Initializing TTF addon failed"))
    (unless (al:install-audio)
      (error "Intializing audio addon failed"))
    (unless (al:init-acodec-addon)
      (error "Initializing audio codec addon failed"))
    (unless (al:restore-default-mixer)
      (error "Initializing default audio mixer failed"))

#+END_SRC

Then we set the configuration variables that might've been set in call to ~start-engine~:

#+NAME: run-engine-5
#+BEGIN_SRC lisp
    (doplist (key val *config-options*)
      (apply #'(setf config) val
             (mapcar #'make-keyword
                     (uiop:split-string (string key) :separator '(#\-)))))

#+END_SRC

Next, we setup various display parameters, such as width and height of the viewport and multisampling.

#+NAME: run-engine-6
#+BEGIN_SRC lisp
    (with-system-config-options
        ((display-windowed display-multisampling display-width display-height))
      (al:set-new-display-flags
       ;; TODO : fix fullscreen
       (if display-windowed
           '(:windowed)
           '(:fullscreen-window :frameless)))
      (unless (zerop display-multisampling)
        (al:set-new-display-option :sample-buffers 1 :require)
        (al:set-new-display-option :samples display-multisampling :require))

#+END_SRC

After that, we create the display and initialize various liballegro event sources, so that we can process the events in our game loop:

#+NAME: run-engine-7
#+BEGIN_SRC lisp
      (let ((display (al:create-display display-width display-height))
            (event-queue (al:create-event-queue)))
        (when (cffi:null-pointer-p display)
          (error "Initializing display failed"))
        (al:inhibit-screensaver t)
        (al:set-window-title display *game-name*)
        (al:register-event-source event-queue
                                  (al:get-display-event-source display))
        (al:install-keyboard)
        (al:register-event-source event-queue (al:get-keyboard-event-source))
        (al:install-mouse)
        (al:register-event-source event-queue (al:get-mouse-event-source))
        (setf *event-source* (cffi:foreign-alloc '(:struct al::event-source)))
        (al:init-user-event-source *event-source*)
        (al:register-event-source event-queue *event-source*)

#+END_SRC

A few more tweaks, related to the accelerated bitmaps in video memory and random number generator:

#+NAME: run-engine-8
#+BEGIN_SRC lisp
        (al:set-new-bitmap-flags '(:video-bitmap))

        (setf *random-state* (make-random-state t))

#+END_SRC

And finally, we can prepare and start the game loop by calling ~game-loop~ function.

First, we initialize the data tables containing various game-specific values from the =*.cdb= resource files they're stored in by the call to ~load-data-tables~. Next, we initialize the ECS subsystem of the engine with a call to ~initialize-systems~, and then call ~game-loop~ function within the confines of ~unwind-protect~ which handles proper finalization of the engine:

#+NAME: run-engine-9
#+BEGIN_SRC lisp
        (unwind-protect
             (progn
               (load-data-tables *table-indices*)
               (initialize-systems)
               (game-loop event-queue))
          (log-info "Shutting engine down")
          (when (entity-valid-p *session-entity*)
            (delete-entity *session-entity*))
          (setf *session-entity* +invalid-entity+)
          (finalize-systems)
          (finalize-entities)
          (finalize-actions)
          (growable-vector-clear *event-queue*)
          (al:inhibit-screensaver nil)
          (al:destroy-user-event-source *event-source*)
          (cffi:foreign-free *event-source*)
          (setf *event-source* (cffi:null-pointer))
          (al:destroy-event-queue event-queue)
          (al:destroy-display display)
          (al:stop-samples)
          (close-config)
          (al:uninstall-system)
          (al:uninstall-audio)
          (al:shutdown-ttf-addon)
          (al:shutdown-font-addon)
          (al:shutdown-image-addon)
          (al:shutdown-primitives-addon)
          (close-fs)))))
  0)
#+END_SRC

*** Game loop

The game loop starts with calling garbage collector using the ~gc~ function from the [[https://common-lisp.net/project/trivial-garbage/][trivial-garbage]] library. After that, leaving some comment in log, we setup the [[https://github.com/cbaggers/livesupport][livesupport]] library by calling ~setup-lisp-repl~. This amazing library allows to feed arbitrary code into REPL while the game is running. Next, by using ~uiop:next~ macro to avoid extra nesting, we prepare some variables for the loop. We read the ~display-vsync~ and ~display-fps~ variables from config (see the [[Config]] section for the discussion of ~with-system-config-options~ macro used for that). We also create a functional renderer instance with a call to ~make-renderer~ (discussed in [[Renderer]] section) and initialize some time counters using the [[https://liballeg.org/a5docs/trunk/time.html#al_get_time][~al:get-time~]] function, namely the timestamp of the last frame, called ~last-tick~ and last livesupport update time called ~last-repl-update~; we update livesupport REPL link once in 0.3 seconds by default, which is set in ~repl-update-interval~ keyword argument to the ~game-loop~ function.

#+NAME: game-loop-1
#+BEGIN_SRC lisp
(declaim
 (ftype
  (function (cffi:foreign-pointer &key (:repl-update-interval double-float)))
  game-loop))
(defunl game-loop (event-queue &key (repl-update-interval 0.3d0))
  "Runs game loop."
  (gc :full t)
  (log-info "Starting game loop")
  (livesupport:setup-lisp-repl)
  (uiop:nest
   (with-system-config-options ((display-vsync display-fps)))
   (let* ((vsync display-vsync)
          (renderer (make-renderer))
          (last-tick (the double-float (al:get-time)))
          (last-repl-update last-tick)))
#+END_SRC

Next, we allocate [[https://liballeg.org/a5docs/trunk/events.html#allegro_event][liballegro event]] foreign structure with ~cffi:with-foreign-object~ macro and sleep for approximately 1/60 of a second so that the calculated FPS value for the very first frame does not cause division by zero. After that, we finally start the actual game loop with its body wrapped into ~restart-case~ for some nice restarts we'll discuss in a few moments.

#+NAME: game-loop-2
#+BEGIN_SRC lisp
   (cffi:with-foreign-object (event '(:union al:event))
     (sleep 0.016)
     (loop
       :do (restart-case
               (progn
#+END_SRC

First of all, in the beginning of every frame, we process the events. We first try to feed the allegro events we receive with [[https://liballeg.org/a5docs/trunk/events.html#al_get_next_event][~al:get-next-event~]] to the [[https://github.com/Immediate-Mode-UI/Nuklear/][Nuklear]] library using ~ui-handle-event~ helper in case some UI windows are active. In case the event is not handled by Nuklear, we call ~systems-handle-event~ helper we'll discuss in a moment. Also note that we can receive several events per frame, so we also use a loop here.

#+NAME: game-loop-3
#+BEGIN_SRC lisp
                 (nk:with-input (ui-context)
                   (unless (loop :while (al:get-next-event event-queue event)
                                 :always (or (ui-handle-event event)
                                             (systems-handle-event event)))
                     (loop-finish)))
#+END_SRC

~ui-handle-event~ helper basically just feeds the event to the ~nk:allegro-handle-event~ function from [[https://gitlab.com/lockie/cl-liballegro-nuklear][cl-liballegro-nuklear]] wrapper library. The minor optimization here is that we don't do that if there are no active UI windows, which we determine by the call to ~ui-on-p~ function described in [[UI system]] section.

#+NAME: ui-handle-event
#+BEGIN_SRC lisp
(declaim
 #-d2c-debug (inline ui-handle-event)
 (ftype (function (cffi:foreign-pointer) boolean) ui-handle-event))
(defun ui-handle-event (event)
  (and (ui-on-p)
       (positive-fixnum-p (the fixnum (nk:allegro-handle-event event)))))
#+END_SRC

~systems-hande-event~ helper serves as a bridge between the low-level liballegro events and high-level in-game events described in detail in [[Events]] section. It calls ~make-allegro-event~ constructor function to make an instance of in-game event and then feeds that instance to all ECS systems; we'll talk more about what ECS is in [[ECS][corresponding section]]. Note that ~systems-handle-event~ returns ~nil~ only when the type of event is ~:display-close~, which is produced by liballegro when the game window is closed. This fact is used in the game loop to finish it.

#+NAME: systems-handle-event
#+BEGIN_SRC lisp
(declaim
 #-d2c-debug (inline systems-handle-event)
 (ftype (function (cffi:foreign-pointer) boolean) systems-handle-event))
(defun systems-handle-event (event)
  (let* ((type (cffi:foreign-slot-value event '(:union al:event) 'al::type))
         (allegro-event (make-allegro-event :type type :struct event)))
    ;; NOTE : processing allegro event without queueing, because event struct
    ;; is stack allocated
    (with-systems system
      (process-event system allegro-event))
    (not (eq type :display-close))))
#+END_src

In game loop, after processing all low-level liballegro events, we separately process high-level events with ~process-events~ function, since the low-level event might trigger one or more high-level events and we don't want to deal with ordering issues.

After all of the events are processed, we do some time-based calculations. We get current frame's timestamp into the ~current-tick~ variable, check if we need to update livesupport REPL link with ~livesupport:update-repl-link~, calculate delta time between current frame and the previous one into the ~*delta-time*~ global variable and display FPS value if it is set in config.

#+NAME: game-loop-4
#+BEGIN_SRC lisp
                 (process-events)
                 (let ((current-tick (the double-float (al:get-time))))
                   (when (> (- current-tick last-repl-update)
                            repl-update-interval)
                     (livesupport:update-repl-link)
                     (setf last-repl-update current-tick))
                   (setf *delta-time* (- current-tick last-tick))
                   ;; TODO : draw FPS counter above the UI
                   (when display-fps
                     ;; TODO : smooth FPS counter, like in allegro examples
                     (add-debug-text :fps "FPS: ~d" (round 1 *delta-time*)))
#+END_SRC

Next, we call ~process-actions~ function which processes the actions related to every ECS system. Actions constitute separate framework used for multi-frame stateful actions performed by in-game entities; we'll cover those in detail in [[Actions][corresponding section]].

After that, we call ~system-update~ generic method in loop for every ECS system, which updates the aspects of the state of in-game entities being handled by those systems.

Further down the line, we call ~system-draw~ generic method which arranges the drawing commands needed for those state aspects to be drawn on screen.

#+NAME: game-loop-5
#+BEGIN_SRC lisp
                   (process-actions)
                   ;; TODO : use separate threads for updating?..
                   (with-systems sys
                     ;; TODO : replace system-update with event?.. maybe even
                     ;; system-draw too?..
                     (system-update sys))
                   (with-systems sys
                     (system-draw sys renderer))
#+END_SRC

After those issues are handled, we proceed to actual drawing. We call [[https://liballeg.org/a5docs/trunk/graphics.html#al_clear_to_color][~al:clear-to-color~]] to flush the screen with the same black color, and then we call ~do-draw~ function which makes the functional renderer instance to do the actual draw calls. After swapping ~last-tick~ with ~current-tick~, we also call [[https://liballeg.org/a5docs/trunk/display.html#al_wait_for_vsync][~al:wait-for-vsync~]] if the vertical sync was set in config, and we call ~nk:allegro-render~ to render UI windows, if any. With that, we're finished with the draw calls, and we finally call [[https://liballeg.org/a5docs/trunk/display.html#al_flip_display][~al:flip-display~]] to swap drawing buffers.

#+NAME: game-loop-6
#+BEGIN_SRC lisp
                   (al:clear-to-color (al:map-rgb 0 0 0))
                   (do-draw renderer)
                   (setf last-tick current-tick))
                 (when vsync
                   (setf vsync (al:wait-for-vsync)))
                 (nk:allegro-render)
                 (al:flip-display))
#+END_SRC

At the bottom of the game loop body, we have a ~next-iteration~ restart, which allows to continue to the next iteration of loop when some condition arises within.

#+NAME: game-loop-7
#+BEGIN_SRC lisp
             ;; TODO restart to terminate the loop
             (next-iteration ()
               :report "Proceed to next game loop iteration."
               nil))))))
#+END_SRC

*** Game session

There are a couple more functions defined in =d2clone-kit.lisp= file, and they both are related to the game session and both called only from GUI scripts.

First one, ~new-game~ initializes a new game by recreating ~*session-entity*~, which is the parent of all entities created in the game session (we'll delve into entities in a few). It also clears the event queue.

#+NAME: new-game
#+BEGIN_SRC lisp
(defun new-game ()
  "Starts new game."
  (log-info "Starting new game")
  (when (entity-valid-p *session-entity*)
    (delete-entity *session-entity*))
  (growable-vector-clear *event-queue*)
  (setf (player-system-last-target *player-system*) +invalid-entity+)
  (setf *session-entity* (make-entity))
  (dolist (spec *new-game-object-specs*)
    (make-object spec *session-entity*)))
#+END_SRC

The second one, ~game-started-p~ returns boolean indicating whether there currently is an active gameplay session.

#+NAME: game-started-p
#+BEGIN_SRC lisp
(declaim
 #-d2c-debug (inline game-started-p)
 (ftype (function () boolean) game-started-p))
(defun game-started-p ()
  "Returns boolean indicating whether the game session is currently running."
  ;; HACK
  (entity-valid-p (player-system-entity *player-system*)))
#+END_SRC

** Logging

#+BEGIN_SRC lisp :tangle log.lisp :noweb yes :exports none
<<preamble>>

<<init-log>>

<<cfuns>>

<<defunl>>

<<last-message>>

<<trace-1>>
<<trace-2>>

<<deflog>>

<<with-condition-reporter>>
#+END_SRC

~init-log~ function first constructs the name of the log file, which would be =log.txt= residing in data directory. After that, it actually sets this file name to liballegro by setting the =ALLEGRO_TRACE= environment variable. Next, it tweaks a few logging parameters of liballegro. Namely, it (1) turns off the display of source code lines of log messages, because we can't reliably and easily get those in CL, and (2) it sets the log severity level, which by default is =info= and is being set in ~level~ optional argument to ~init-log~.

#+NAME: init-log
#+BEGIN_SRC lisp
(defun init-log (data-dir &optional (level "info"))
  (let ((log-file
          (merge-pathnames
           (make-pathname :name "log" :type "txt")
           data-dir)))
    ;; TODO : wait for liballegro 5.2.8 to release and then call
    ;;  al_register_trace_handler to handle output to both stdout & logfile
    (setf (uiop:getenv "ALLEGRO_TRACE")
          (namestring log-file)))
  (al:set-config-value (al:get-system-config) "trace" "lines" "0")
  (al:set-config-value (al:get-system-config) "trace" "level" level))
#+END_SRC

~%trace~ function is pivotal in the logging subsystem. It puts the messages with given severity level from Lisp side into liballegro log. To do that, it uses a couple of internal liballegro functions which are not a part of public interface. Therefore, we have to import those functions using CFFI:

#+NAME: cfuns
#+BEGIN_SRC lisp
(cffi:defcfun ("_al_trace_prefix" trace-prefix) :boolean
  (channel :string) (level :int) (file :string) (line :int) (function :string))

(cffi:defcfun ("_al_trace_suffix" trace-suffix) :void
  (msg :string) &rest)
#+END_SRC

The heavy lifting of logging is done by the ~do-trace~ local function, which first calls ~trace-prefix~ internal function we've imported, and if it succeeds, it calls ~trace-suffix~ further down; this is part of calling protocol of those functions. We add extra newline to the log message to be output, and after that we split it by 1024 byte portions, since this is the size of internal liballegro buffer, and if we don't do the splitting, the message will get truncated.

#+NAME: trace-1
#+BEGIN_SRC lisp
(defun %trace (level message args)
  (flet
      ((do-trace (level function-name message)
         (when (trace-prefix "d2clone-kit" level "" 0 function-name)
           (loop :with finalized-message := (format nil "~a~%" message)
                 :with length := (length finalized-message)
                 :for i :of-type fixnum :from 0 :to length :by 1024
                 :do (trace-suffix
                      "%s"
                      :string
                      (subseq finalized-message i (min length (+ i 1024))))))))
#+END_SRC

The ~%trace~ function first formats the arguments it has been given using the standard CL ~format~ function.

~%trace~ also features duplicate message detection which could be found in some popular logging utilities. It does that using the ~*last-message*~ and ~*last-message-repetitions*~ global variables defined above:

#+NAME: last-message
#+BEGIN_SRC lisp
(declaim (string *last-message*)
         (fixnum *last-message-repetitions*))
(global-vars:define-global-var *last-message* "")
(global-vars:define-global-var *last-message-repetitions* 0)
#+END_SRC

If the previous message was repeated more than once, before putting another message we add the line saying that /last message repeated/ that count of /times/.

After that, we finally put the actual log message along with the function name using ~do-trace~.

#+NAME: trace-2
#+BEGIN_SRC lisp
    (let ((full-message (apply #'format (list* nil message args))))
      (cond
        ((string= *last-message* full-message)
         (incf *last-message-repetitions*))
        (t
         (unless (zerop *last-message-repetitions*)
           (do-trace 1 "trace" (format nil "[last message repeated ~a times]"
                                       *last-message-repetitions*))
           (setf *last-message-repetitions* 0))
         (do-trace level (string-downcase *function-name*) full-message)
         (setf *last-message* full-message))))))
#+END_SRC

In C world, one can use [[https://gcc.gnu.org/onlinedocs/gcc/Function-Names.html][~__func__~]] macro to get the name of the current function. CL lacks that feature, so we had to implement it using our own ~defunl~ macro instead of standard ~defun~ for functions we want to see in log.

~defunl~ basically just puts the function name to the dynamic variable ~*function-name*~ right before the function body starts.

#+NAME: defunl
#+BEGIN_SRC lisp
(defvar *function-name* "")

(defmacro defunl (fname lambda-list &body body)
  "DEFUN wrapper which sets correct current function name for logging
functions."
  (let ((docstring (when (stringp (car body)) (pop body))))
    `(defun ,fname ,lambda-list
       ,@(ensure-list docstring)
       (let ((*function-name* (quote ,fname)))
         ,@body))))
#+END_SRC

This variable is being used to supply the function name to ~do-trace~ local function we've seen above, so that the names of Lisp functions can nicely appear in logs like that:

#+BEGIN_EXAMPLE
system      I al_install_system [   0.00000] Allegro version: 5.2.7
d2clone-kit I start-engine      [   0.00027] Starting d2clone-kit engine v0.1.2
d2clone-kit I init-fs           [   0.00031] Appending /home/andrew/Progs/GAMEDEV/d2clone-kit/Resources to mount points
#+END_EXAMPLE

Finally, we don't use the ~%trace~ function itself throughout the engine codebase. Instead, we define a few wrappers for every log severity level supported by liballegro using the ~deflog~ macro, which just defines a small function with docstrings and everything wrapping ~%trace~ with the nice names like ~trace-debug~, ~trace-info~ etc.:

#+NAME: deflog
#+BEGIN_SRC lisp
(defmacro deflog (name level docstring)
  (let
      ((function-name (intern (concatenate 'string "LOG-" (symbol-name name)))))
    `(defun ,function-name (message &rest args)
       ,@(ensure-list docstring)
       (%trace ,level message args))))

(deflog debug 0
  "Adds formatted message MESSAGE using placeholder arguments ARGS to
  liballegro debug channel.")

(deflog info 1
  "Adds formatted message MESSAGE using placeholder arguments ARGS to
  liballegro info channel.")

(deflog warn 2
  "Adds formatted message MESSAGE using placeholder arguments ARGS to
  liballegro warn channel.")

(deflog error 3
  "Adds formatted message MESSAGE using placeholder arguments ARGS to
  liballegro error channel.")
#+END_SRC

** Config

** Renderer

** UI system

** Events

** ECS

** Actions

# Local Variables:
# org-src-preserve-indentation: t
# End:
