#+STARTUP: showall indent hidestars

* Quickstart

d2clone-kit engine requires [[https://liballeg.org][liballegro]] game programming library to function (*unrelated* to Allegro Common Lisp; d2clone-kit supports variety of Common Lisp compilers, including SBCL).

To install liballegro development files, refer to your distribution's package manager; for instance, on Debian derivatives (including Ubuntu and Mint) issue the following command:

#+BEGIN_SRC shell
sudo apt-get install liballegro-acodec5-dev liballegro-audio5-dev \
    liballegro-image5-dev liballegro-dialog5-dev liballegro-ttf5-dev \
    liballegro-physfs5-dev liballegro-video5-dev
#+END_SRC

Now, clone the repo to your [[https://quicklisp.org][Quicklisp]] directory and download resource files:

#+BEGIN_SRC shell
export QUICKLISP_DIR=~/quicklisp  # adjust according to your Quicklisp path
git clone https://gitlab.com/lockie/d2clone-kit $QUICKLISP_DIR/local-projects/d2clone-kit
wget https://gitlab.com/lockie/darkness-looming-the-dawn/-/raw/master/Resources/assets.zip \
    -P $QUICKLISP_DIR/local-projects/d2clone-kit/Resources/
cd $QUICKLISP_DIR/local-projects/d2clone-kit/src/
#+END_SRC

Start your favourite Lisp (or slime/sly) from engine's =src/= subdirectory.
To launch the built-in engine demo using the resources you've downloaded, type in REPL:

#+BEGIN_SRC lisp
(ql:register-local-projects)
(ql:quickload :d2clone-kit)
(d2clone-kit:demo)
#+END_SRC

* Entry point

The entry point to the game, should it be ~d2clone-kit:demo~ or other kind of ~main~ function supplied to ~:entry-point~ argument of game's ~asdf:defsystem~, just needs to call ~start-engine~ with appropriate arguments:

#+NAME: demo
#+BEGIN_SRC lisp
(defun demo ()
  "Runs built-in engine demo."
  (start-engine
   "demo"
   '(((:camera)
      (:coordinate :x 0d0 :y 0d0))
     ((:player)
      (:coordinate :x 0d0 :y 0d0)
      (:sprite :prefab :heroine :layers-initially-toggled (:head :clothes))
      (:character)
      (:hp :current 100d0 :maximum 100d0)
      (:mana :current 100d0 :maximum 100d0)
      (:combat :min-damage 1d0 :max-damage 2d0))
     ((:mob :name "Spiderant")
      (:coordinate :x 2d0 :y 2d0)
      (:sprite :prefab :spiderant :layers-initially-toggled (:body))
      (:character :speed 1d0)
      (:hp :current 15d0 :maximum 15d0)
      (:combat :min-damage 1d0 :max-damage 10d0))
     ;; ((:mob :name "Spiderant")
     ;;  (:coordinate :x 4d0 :y 4d0)
     ;;  (:sprite :prefab :spiderant :layers-initially-toggled (:body))
     ;;  (:character :speed 1d0)
     ;;  (:hp :current 50d0 :maximum 50d0))
     ;; ((:mob :name "Spiderant")
     ;;  (:coordinate :x 3d0 :y 3d0)
     ;;  (:sprite :prefab :spiderant :layers-initially-toggled (:body))
     ;;  (:character :speed 1d0)
     ;;  (:hp :current 50d0 :maximum 50d0))
     ((:coordinate :x 0d0 :y 0d0)
      (:map :prefab :map)))
   nil))
#+END_SRC

* Engine

To start the engine, we save the arguments passed to ~start-engine~ to dynamic variables (to properly pass it to CFFI callback we'll discuss in a moment).

Then we use ~float-features:with-float-traps-masked~ from Shinmera's [[https://shinmera.github.io/float-features][float-features]] library to stop Lisp popping up with floating point errors (like e.g. [[https://en.wikipedia.org/wiki/Arithmetic_underflow][underflow]]) which are usual (and often ignored) in C world.

Finally, we call [[https://liballeg.org/a5docs/trunk/misc.html#al_run_main][al:run-main]] from liballegro with the ~run-engine~ [[https://common-lisp.net/project/cffi/manual/html_node/defcallback.html][CFFI callback]]; this is required in order for the game to be able to run under MacOS with its weird main thread rules.

#+NAME: start-engine
#+BEGIN_SRC lisp
(defunl start-engine (game-name new-game-object-specs table-indices
                                &rest config)
  "Initializes and starts engine to run the game named by GAME-NAME.
NEW-GAME-OBJECT-SPECS is list of game object specifications to be created when
 the new game is started with MAKE-OBJECT. TABLE-INDICES, if non-nil,
 specifies the columns in indices to build from a data tables read from .cdb
 file with BUILD-DATA-TABLES. CONFIG plist is used to override variables read
 from config file.

See MAKE-OBJECT
See BUILD-DATA-TABLES"
  (let ((*game-name* game-name)
        (*sanitized-game-name* (sanitize-filename game-name))
        (*new-game-object-specs* new-game-object-specs)
        (*config-options* config)
        (*table-indices* table-indices))
    (float-features:with-float-traps-masked
        (:divide-by-zero :invalid :inexact :overflow :underflow)
      (al:run-main 0 (cffi:null-pointer) (cffi:callback run-engine)))))
#+END_SRC

~run-engine~ begins with ~with-condition-reporter~ macro:

#+NAME: run-engine-1
#+BEGIN_SRC lisp
(cffi:defcallback run-engine :int ((argc :int) (argv :pointer))
  (declare (ignore argc argv))
  (with-condition-reporter
#+END_SRC

This macro executes a block of code, and if it triggers an unhandled condition, it displays nice GUI dialog with [[https://liballeg.org/a5docs/trunk/native_dialog.html#al_show_native_message_box][al:show-native-message-box]] with its description and nice reference to the original Diablo 2 error message. Of course this only happens when you're not running your Lisp under debugger. Also, this macro puts condition description as well as full backtrace to liballegro log.

#+NAME: with-condition-reporter
#+BEGIN_SRC lisp
(defmacro with-condition-reporter (&body body)
  "Executes BODY with generic error handler which puts full error
condition info including backtrace to liballegro log and displays error
messagebox when not in debugger."
  `(handler-bind
       ((error #'(lambda (e)
                   (log-error "~a"
                              (with-output-to-string (s)
                                (uiop:print-condition-backtrace e :stream s)))
                   (unless *debugger-hook*
                     (al:show-native-message-box
                      (cffi:null-pointer) "Hey guys"
                      "We got a big error here :(" (format nil "~a" e)
                      (cffi:null-pointer) :error)))))
     ,@body))
#+END_SRC

So the next thing ~run-engine~ does is determining the data directory (something like =~/.local/share/demo/=, where =demo= is the name of the game sans forbidden characters, which is held in ~*sanitized-game-name*~ variable).

#+NAME: run-engine-2
#+BEGIN_SRC lisp
    (let ((data-dir
            (merge-pathnames
             (make-pathname :directory `(:relative ,*sanitized-game-name*))
             (uiop:xdg-data-home))))
      (ensure-directories-exist data-dir)
#+END_SRC

Next, we initialize core liballegro facilities: logging, the library itself, filesystem and configuration subsystems.

#+NAME: run-engine-3
#+BEGIN_SRC lisp
      (init-log data-dir)
      (log-info "Starting d2clone-kit engine v~a" +engine-version+)
      (al:set-app-name *sanitized-game-name*)
      (al:init)
      (init-fs *sanitized-game-name* data-dir)
      (init-config))

#+END_SRC

Afterwards, we initialize various liballegro addons:

#+NAME: run-engine-4
#+BEGIN_SRC lisp
    ;; TODO : proper recover from those errors
    (unless (al:init-primitives-addon)
      (error "Initializing primitives addon failed"))
    (unless (al:init-image-addon)
      (error "Initializing image addon failed"))
    (al:init-font-addon)
    (unless (al:init-ttf-addon)
      (error "Initializing TTF addon failed"))
    (unless (al:install-audio)
      (error "Intializing audio addon failed"))
    (unless (al:init-acodec-addon)
      (error "Initializing audio codec addon failed"))
    (unless (al:restore-default-mixer)
      (error "Initializing default audio mixer failed"))

#+END_SRC

Then we set the configuration variables that might've been set in call to ~start-engine~:

#+NAME: run-engine-5
#+BEGIN_SRC lisp
    (doplist (key val *config-options*)
      (apply #'(setf config) val
             (mapcar #'make-keyword
                     (uiop:split-string (string key) :separator '(#\-)))))

#+END_SRC

Next, we setup various display parameters, such as width and height of the viewport and multisampling.

#+NAME: run-engine-6
#+BEGIN_SRC lisp
    (with-system-config-options
        ((display-windowed display-multisampling display-width display-height))
      (al:set-new-display-flags
       ;; TODO : fix fullscreen
       (if display-windowed
           '(:windowed)
           '(:fullscreen-window :frameless)))
      (unless (zerop display-multisampling)
        (al:set-new-display-option :sample-buffers 1 :require)
        (al:set-new-display-option :samples display-multisampling :require))

#+END_SRC

After that, we create the display and initialize various liballegro event sources, so that we can process the events in our game loop:

#+NAME: run-engine-7
#+BEGIN_SRC lisp
      (let ((display (al:create-display display-width display-height))
            (event-queue (al:create-event-queue)))
        (when (cffi:null-pointer-p display)
          (error "Initializing display failed"))
        (al:inhibit-screensaver t)
        (al:set-window-title display *game-name*)
        (al:register-event-source event-queue
                                  (al:get-display-event-source display))
        (al:install-keyboard)
        (al:register-event-source event-queue (al:get-keyboard-event-source))
        (al:install-mouse)
        (al:register-event-source event-queue (al:get-mouse-event-source))
        (setf *event-source* (cffi:foreign-alloc '(:struct al::event-source)))
        (al:init-user-event-source *event-source*)
        (al:register-event-source event-queue *event-source*)

#+END_SRC

A few more tweaks, related to the accelerated bitmaps in video memory, random number generator and the data tables containing various game-specific values:

#+NAME: run-engine-8
#+BEGIN_SRC lisp
        (al:set-new-bitmap-flags '(:video-bitmap))

        (setf *random-state* (make-random-state t))

        (setf *data-tables*
              (build-data-tables
               (load-castledb-tables
                (make-instance 'character-stream
                               :path (format nil "tables/~a.cdb"
                                             *sanitized-game-name*)))
               *table-indices*))

#+END_SRC

And finally, we can prepare and start the game loop. First, we initialize the ECS subsystem of the engine with a call to ~initialize-systems~, and then call ~game-loop~ function within the confines of ~unwind-protect~ which handles proper finalization of the engine:

#+NAME: run-engine-9
#+BEGIN_SRC lisp
        (unwind-protect
             (progn
               (initialize-systems)
               (game-loop event-queue))
          (log-info "Shutting engine down")
          (when (entity-valid-p *session-entity*)
            (delete-entity *session-entity*))
          (setf *session-entity* +invalid-entity+)
          (finalize-systems)
          (finalize-entities)
          (finalize-actions)
          (growable-vector-clear *event-queue*)
          (al:inhibit-screensaver nil)
          (al:destroy-user-event-source *event-source*)
          (cffi:foreign-free *event-source*)
          (setf *event-source* (cffi:null-pointer))
          (al:destroy-event-queue event-queue)
          (al:destroy-display display)
          (al:stop-samples)
          (close-config)
          (al:uninstall-system)
          (al:uninstall-audio)
          (al:shutdown-ttf-addon)
          (al:shutdown-font-addon)
          (al:shutdown-image-addon)
          (al:shutdown-primitives-addon)
          (close-fs)))))
  0)
#+END_SRC

* Game loop

#+NAME: game-loop
#+BEGIN_SRC lisp
(defunl game-loop (event-queue &key (repl-update-interval 0.3))
  "Runs game loop."
  (gc :full t)
  (log-info "Starting game loop")
  (livesupport:setup-lisp-repl)
  (with-system-config-options ((display-vsync display-fps))
    (let* ((vsync display-vsync)
           (renderer (make-renderer))
           (last-tick (al:get-time))
           (last-repl-update last-tick))
      (cffi:with-foreign-object (event '(:union al:event))
        (sleep 0.016)
        ;; TODO : restart to continue loop from the next iteration
        (loop :do
          (nk:with-input (ui-context)
            (unless (loop :while (al:get-next-event event-queue event)
                          :always (or (ui-handle-event event)
                                      (systems-handle-event event)))
              (loop-finish)))
          (process-events)
          (let ((current-tick (al:get-time)))
            (when (> (- current-tick last-repl-update) repl-update-interval)
              (livesupport:update-repl-link)
              (setf last-repl-update current-tick))
            (when display-fps
              ;; TODO : smooth FPS counter, like in allegro examples
              (add-debug-text :fps "FPS: ~d"
                              (round 1 (- current-tick last-tick))))
            (setf *delta-time* (- current-tick last-tick))
            (process-actions)
            (with-systems sys
              ;; TODO : replace system-update with event?.. maybe even
              ;; system-draw too?..
              (system-update sys))
            (with-systems sys
              (system-draw sys renderer))
            (al:clear-to-color (al:map-rgb 0 0 0))
            (do-draw renderer)
            (setf last-tick current-tick))
          (when vsync
            (setf vsync (al:wait-for-vsync)))
          (nk:allegro-render)
          (al:flip-display))))))
#+END_SRC

* Logging

~defunl~ is the simple macro wrapper over standard ~defun~, which puts the function name to the dynamic variable ~*function-name*~.

#+NAME: defunl
#+BEGIN_SRC lisp
(defvar *function-name* "")

(defmacro defunl (fname lambda-list &body body)
  "DEFUN wrapper which sets correct current function name for logging
functions."
  (let ((docstring (when (stringp (car body)) (pop body))))
    `(defun ,fname ,lambda-list
       ,@(ensure-list docstring)
       (let ((*function-name* (quote ,fname)))
         ,@body))))
#+END_SRC

This variable is being used to supply the function name to liballegro logging subsytem, so that the names of Lisp functions can nicely appear in logs, like that:

#+BEGIN_EXAMPLE
system      I al_install_system [   0.00000] Allegro version: 5.2.7
d2clone-kit I start-engine      [   0.00027] Starting d2clone-kit engine v0.1.2
d2clone-kit I init-fs           [   0.00031] Appending /home/andrew/Progs/GAMEDEV/d2clone-kit/Resources to mount points
#+END_EXAMPLE

* Tangling :noexport:
#+NAME: preamble
#+BEGIN_SRC lisp
;;;; Copyright (C) 2020-2021 Andrew Kravchuk and contributors
;;;;
;;;; This program is free software: you can redistribute it and/or modify
;;;; it under the terms of the GNU General Public License as published by
;;;; the Free Software Foundation, either version 3 of the License, or
;;;; (at your option) any later version.
;;;;
;;;; This program is distributed in the hope that it will be useful,
;;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;;; GNU General Public License for more details.
;;;;
;;;; You should have received a copy of the GNU General Public License
;;;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;;;; WARNING: DO NOT EDIT, AUTO-GENERATED CODE. Edit doc.org instead.

(in-package :d2clone-kit)
#+END_SRC

#+BEGIN_SRC lisp :tangle d2clone-kit.lisp :noweb yes :exports none
<<preamble>>

<<game-loop>>

<<run-engine-1>>
<<run-engine-2>>
<<run-engine-3>>
<<run-engine-4>>
<<run-engine-5>>
<<run-engine-6>>
<<run-engine-7>>
<<run-engine-8>>
<<run-engine-9>>

<<start-engine>>

<<demo>>
#+END_SRC

#+BEGIN_SRC lisp :tangle log.lisp :noweb yes :exports none
<<preamble>>

<<defunl>>

<<with-condition-reporter>>
#+END_SRC


# Local Variables:
# org-src-preserve-indentation: t
# End:
