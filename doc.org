#+STARTUP: showall indent hidestars

* Quickstart

d2clone-kit engine requires [[https://liballeg.org][liballegro]] game programming library to function (*unrelated* to Allegro Common Lisp; d2clone-kit supports variety of Common Lisp compilers, including SBCL).

To install liballegro development files, refer to your distribution's package manager; for instance, on Debian derivatives (including Ubuntu and Mint) issue the following command:

#+BEGIN_SRC shell
sudo apt-get install liballegro-acodec5-dev liballegro-audio5-dev \
    liballegro-image5-dev liballegro-dialog5-dev liballegro-ttf5-dev \
    liballegro-physfs5-dev liballegro-video5-dev
#+END_SRC

Now, clone the repo to your [[https://quicklisp.org][Quicklisp]] directory and download resource files (note that you don't have to unpack the resources archive, d2clone-kit features reading files from zip archives):

#+BEGIN_SRC shell
export QUICKLISP_DIR=~/quicklisp  # adjust according to your Quicklisp path
git clone https://gitlab.com/lockie/d2clone-kit $QUICKLISP_DIR/local-projects/d2clone-kit
wget https://gitlab.com/lockie/darkness-looming-the-dawn/-/raw/master/Resources/assets.zip \
    -P $QUICKLISP_DIR/local-projects/d2clone-kit/Resources/
cd $QUICKLISP_DIR/local-projects/d2clone-kit/src/
#+END_SRC


Start your favourite Lisp (or slime/sly) from engine's =src/= subdirectory.
To launch the built-in engine demo using the resources you've downloaded, type in REPL:

#+BEGIN_SRC lisp
(ql:register-local-projects)
(ql:quickload :d2clone-kit)
(d2clone-kit:demo)
#+END_SRC

* Source code walkthrough

d2clone-kit is licensed under the GNU GPL license version 3.

We put all of engine's source code into ~:d2clone-kit~ package.

#+NAME: preamble
#+BEGIN_SRC lisp
;;;; Copyright (C) 2020-2021 Andrew Kravchuk and contributors
;;;;
;;;; This program is free software: you can redistribute it and/or modify
;;;; it under the terms of the GNU General Public License as published by
;;;; the Free Software Foundation, either version 3 of the License, or
;;;; (at your option) any later version.
;;;;
;;;; This program is distributed in the hope that it will be useful,
;;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;;; GNU General Public License for more details.
;;;;
;;;; You should have received a copy of the GNU General Public License
;;;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;;;; WARNING: DO NOT EDIT, AUTO-GENERATED CODE. Edit doc.org instead.

(in-package :d2clone-kit)
#+END_SRC

** Entry point

#+BEGIN_SRC lisp :tangle d2clone-kit.lisp :noweb yes :exports none
<<preamble>>

<<ui-handle-event>>

<<systems-handle-event>>

<<game-loop-1>>
<<game-loop-2>>
<<game-loop-3>>
<<game-loop-4>>
<<game-loop-5>>
<<game-loop-6>>
<<game-loop-7>>

<<callback-globals>>

<<new-game>>

<<game-started-p>>

<<package-version>>

<<run-engine-1>>
<<run-engine-2>>
<<run-engine-3>>
<<run-engine-4>>
<<run-engine-5>>
<<run-engine-6>>
<<run-engine-7>>
<<run-engine-8>>
<<run-engine-9>>

<<start-engine>>

<<demo>>
#+END_SRC

The entry point to the game, should it be ~d2clone-kit:demo~ or other kind of ~main~ function supplied to ~:entry-point~ argument of game's ~asdf:defsystem~, just needs to call ~start-engine~ with appropriate arguments:

#+NAME: demo
#+BEGIN_SRC lisp
(defun demo ()
  "Runs built-in engine demo."
  (start-engine
   "demo"
   ;; TODO : load that from map file!
   ;; TODO : also store initial player position in the file
   ;;  (or some kind of "entrypoint" or "spawnpoint")
   '(((:camera)
      (:coordinate :x 0d0 :y 0d0))
     ((:player)
      (:coordinate :x 0d0 :y 0d0)
      (:sprite :prefab :heroine :layers-initially-toggled (:head :clothes))
      (:character)
      (:hp :current 100d0 :maximum 100d0)
      (:mana :current 100d0 :maximum 100d0)
      (:combat :min-damage 1d0 :max-damage 2d0))
     ((:mob :name "Spiderant")
      (:coordinate :x 2d0 :y 2d0)
      (:sprite :prefab :spiderant :layers-initially-toggled (:body))
      (:character :speed 1d0)
      (:hp :current 15d0 :maximum 15d0)
      (:combat :min-damage 1d0 :max-damage 10d0))
     ;; ((:mob :name "Spiderant")
     ;;  (:coordinate :x 4d0 :y 4d0)
     ;;  (:sprite :prefab :spiderant :layers-initially-toggled (:body))
     ;;  (:character :speed 1d0)
     ;;  (:hp :current 50d0 :maximum 50d0))
     ;; ((:mob :name "Spiderant")
     ;;  (:coordinate :x 3d0 :y 3d0)
     ;;  (:sprite :prefab :spiderant :layers-initially-toggled (:body))
     ;;  (:character :speed 1d0)
     ;;  (:hp :current 50d0 :maximum 50d0))
     ((:coordinate :x 0d0 :y 0d0)
      (:map :prefab :map)))
   nil))
#+END_SRC

** Engine

To start the engine, we'll save the arguments passed to ~start-engine~ to dynamic variables defined below to properly pass it to CFFI callback we'll discuss in a moment:

#+NAME: callback-globals
#+BEGIN_SRC lisp
(defvar *game-name*)
(defvar *sanitized-game-name*)
(defvar *new-game-object-specs*)
(defvar *config-options*)
(defvar *table-indices*)
#+END_SRC

Then we use ~float-features:with-float-traps-masked~ from Shinmera's [[https://shinmera.github.io/float-features][float-features]] library to stop Lisp popping up with floating point errors (like e.g. [[https://en.wikipedia.org/wiki/Arithmetic_underflow][underflow]]) which are usual (and by default ignored) in C world.

Finally, we call [[https://liballeg.org/a5docs/trunk/misc.html#al_run_main][~al:run-main~]] from liballegro with the ~run-engine~ [[https://common-lisp.net/project/cffi/manual/html_node/defcallback.html][CFFI callback]]; this is required in order for the game to be able to run under MacOS with its weird main thread rules.

#+NAME: start-engine
#+BEGIN_SRC lisp
(defunl start-engine (game-name new-game-object-specs table-indices
                                &rest config)
  "Initializes and starts engine to run the game named by GAME-NAME.
NEW-GAME-OBJECT-SPECS is list of game object specifications to be created when
 the new game is started with MAKE-OBJECT. TABLE-INDICES, if non-nil,
 specifies the columns in indices to build from a data tables read from .cdb
 file with BUILD-DATA-TABLES. CONFIG plist is used to override variables read
 from config file.

See MAKE-OBJECT
See BUILD-DATA-TABLES"
  (let ((*game-name* game-name)
        (*sanitized-game-name* (sanitize-filename game-name))
        (*new-game-object-specs* new-game-object-specs)
        (*config-options* config)
        (*table-indices* table-indices))
    (float-features:with-float-traps-masked
        (:divide-by-zero :invalid :inexact :overflow :underflow)
      (al:run-main 0 (cffi:null-pointer) (cffi:callback run-engine)))))
#+END_SRC

~run-engine~ begins with ~with-condition-reporter~ macro:

#+NAME: run-engine-1
#+BEGIN_SRC lisp
(cffi:defcallback run-engine :int ((argc :int) (argv :pointer))
  (declare (ignore argc argv))
  (with-condition-reporter
#+END_SRC

This macro executes a block of code, and if it triggers an unhandled condition, it displays nice GUI dialog with [[https://liballeg.org/a5docs/trunk/native_dialog.html#al_show_native_message_box][~al:show-native-message-box~]] displaying its description and good old "Hey guys" error message. Of course this only happens when you're not running your Lisp under debugger (e.g. slime/sly). Also, this macro puts condition description as well as full backtrace to liballegro log.

#+NAME: with-condition-reporter
#+BEGIN_SRC lisp
(defmacro with-condition-reporter (&body body)
  "Executes BODY with generic error handler which puts full error
condition info including backtrace to liballegro log and displays error
messagebox when not in debugger."
  `(handler-bind
       ((error #'(lambda (e)
                   (log-error "~a"
                              (with-output-to-string (s)
                                (uiop:print-condition-backtrace e :stream s)))
                   (unless *debugger-hook*
                     (al:show-native-message-box
                      (cffi:null-pointer) "Hey guys"
                      "We got a big error here :(" (format nil "~a" e)
                      (cffi:null-pointer) :error)))))
     ,@body))
#+END_SRC

So the next thing ~run-engine~ does is determining the *data directory* (something like =~/.local/share/demo/=, where =demo= is the name of the game sans forbidden characters, which is held in ~*sanitized-game-name*~ variable).

#+NAME: run-engine-2
#+BEGIN_SRC lisp
    (let ((data-dir
            (merge-pathnames
             (make-pathname :directory `(:relative ,*sanitized-game-name*))
             (uiop:xdg-data-home))))
      (ensure-directories-exist data-dir)
#+END_SRC

Next, we initialize core liballegro facilities: logging, the library itself, filesystem and configuration subsystems.

#+NAME: run-engine-3
#+BEGIN_SRC lisp
      ;; TODO : ability to set level e.g. by command line variable
      ;;  (it is not possible through config because of "deadlock")
      (init-log data-dir)
      (al:set-app-name *sanitized-game-name*)
      (al:init)
      (log-info "Starting d2clone-kit engine ~a"
                (package-version "v~a" :d2clone-kit))
      (init-fs *sanitized-game-name* data-dir)
      (init-config))

#+END_SRC

Right after logging is initialized, we emit a newborn cry - the very first log line, reporting engine version by using the following nice helper function which tries to get given package version from [[https://common-lisp.net/project/asdf/][ASDF]]:

#+NAME: package-version
#+BEGIN_SRC lisp
(declaim
 (ftype (function (string (or character symbol string)) (or string null))
        package-version))
(defun package-version (format package)
  "Returns the PACKAGE version from asdf formatted according to FORMAT. If the
package does not exist, then retuns NIL."
  (values
   (when-let (package-instance (asdf:find-system package nil))
     (format nil format (slot-value package-instance 'asdf:version)))))
#+END_SRC

Afterwards, we initialize various [[https://liballeg.org/a5docs/trunk/index.html#addons][liballegro addons]]:

#+NAME: run-engine-4
#+BEGIN_SRC lisp
    ;; TODO : proper recover from those errors (properly finalize)+retry restart
    (unless (al:init-primitives-addon)
      (error "Initializing primitives addon failed"))
    (unless (al:init-image-addon)
      (error "Initializing image addon failed"))
    (al:init-font-addon)
    (unless (al:init-ttf-addon)
      (error "Initializing TTF addon failed"))
    (unless (al:install-audio)
      (error "Intializing audio addon failed"))
    (unless (al:init-acodec-addon)
      (error "Initializing audio codec addon failed"))
    (unless (al:restore-default-mixer)
      (error "Initializing default audio mixer failed"))

#+END_SRC

Then we set the configuration variables that might've been set in call to ~start-engine~:

#+NAME: run-engine-5
#+BEGIN_SRC lisp
    (doplist (key val *config-options*)
      (apply #'(setf config) val
             (mapcar #'make-keyword
                     (uiop:split-string (string key) :separator '(#\-)))))

#+END_SRC

Next, we setup various display parameters, such as width and height of the viewport and multisampling.

#+NAME: run-engine-6
#+BEGIN_SRC lisp
    (with-system-config-options
        ((display-windowed display-multisampling display-width display-height))
      (al:set-new-display-flags
       ;; TODO : fix fullscreen
       (if display-windowed
           '(:windowed)
           '(:fullscreen-window :frameless)))
      (unless (zerop display-multisampling)
        (al:set-new-display-option :sample-buffers 1 :require)
        (al:set-new-display-option :samples display-multisampling :require))

#+END_SRC

After that, we create the display and initialize various liballegro event sources, so that we can process the events in our game loop:

#+NAME: run-engine-7
#+BEGIN_SRC lisp
      (let ((display (al:create-display display-width display-height))
            (event-queue (al:create-event-queue)))
        (when (cffi:null-pointer-p display)
          (error "Initializing display failed"))
        (al:inhibit-screensaver t)
        (al:set-window-title display *game-name*)
        (al:register-event-source event-queue
                                  (al:get-display-event-source display))
        (al:install-keyboard)
        (al:register-event-source event-queue (al:get-keyboard-event-source))
        (al:install-mouse)
        (al:register-event-source event-queue (al:get-mouse-event-source))
        (setf *event-source* (cffi:foreign-alloc '(:struct al::event-source)))
        (al:init-user-event-source *event-source*)
        (al:register-event-source event-queue *event-source*)

#+END_SRC

A few more tweaks, related to the accelerated bitmaps in video memory and random number generator:

#+NAME: run-engine-8
#+BEGIN_SRC lisp
        (al:set-new-bitmap-flags '(:video-bitmap))

        (setf *random-state* (make-random-state t))

#+END_SRC

And finally, we can prepare and start the game loop by calling ~game-loop~ function.

First, we initialize the data tables containing various game-specific values from the =*.cdb= resource files they're stored in by the call to ~load-data-tables~. We'll cover this in detail in [[Data tables]] section. Next, we initialize the ECS subsystem of the engine with a call to ~initialize-systems~, and then call ~game-loop~ function within the confines of ~unwind-protect~ which handles proper finalization of the engine:

#+NAME: run-engine-9
#+BEGIN_SRC lisp
        (unwind-protect
             (progn
               (load-data-tables *table-indices*)
               (initialize-systems)
               (game-loop event-queue))
          (log-info "Shutting engine down")
          (when (entity-valid-p *session-entity*)
            (delete-entity *session-entity*))
          (setf *session-entity* +invalid-entity+)
          (finalize-systems)
          (finalize-entities)
          (finalize-actions)
          (growable-vector-clear *event-queue*)
          (al:inhibit-screensaver nil)
          (al:destroy-user-event-source *event-source*)
          (cffi:foreign-free *event-source*)
          (setf *event-source* (cffi:null-pointer))
          (al:destroy-event-queue event-queue)
          (al:destroy-display display)
          (al:stop-samples)
          (close-config)
          (al:uninstall-system)
          (al:uninstall-audio)
          (al:shutdown-ttf-addon)
          (al:shutdown-font-addon)
          (al:shutdown-image-addon)
          (al:shutdown-primitives-addon)
          (close-fs)))))
  0)
#+END_SRC

*** Game loop

The game loop starts with calling garbage collector using the ~gc~ function from the [[https://common-lisp.net/project/trivial-garbage/][trivial-garbage]] library. After that, leaving some comment in log, we setup the [[https://github.com/cbaggers/livesupport][livesupport]] library by calling ~setup-lisp-repl~. This amazing library allows to feed arbitrary code into REPL while the game is running. Next, by using ~uiop:nest~ macro to avoid extra nesting, we prepare some variables for the loop. We read the ~display-vsync~ and ~display-fps~ variables from config (see the [[Config]] section for the discussion of ~with-system-config-options~ macro used for that). We also create a functional renderer instance with a call to ~make-renderer~ (discussed in [[Renderer]] section) and initialize some time counters using the [[https://liballeg.org/a5docs/trunk/time.html#al_get_time][~al:get-time~]] function, namely the timestamp of the last frame, called ~last-tick~ and last livesupport update time called ~last-repl-update~; we update livesupport REPL link once in 0.3 seconds by default, which is set in ~repl-update-interval~ keyword argument to the ~game-loop~ function.

#+NAME: game-loop-1
#+BEGIN_SRC lisp
(declaim
 (ftype
  (function (cffi:foreign-pointer &key (:repl-update-interval double-float)))
  game-loop))
(defunl game-loop (event-queue &key (repl-update-interval 0.3d0))
  "Runs game loop."
  (gc :full t)
  (log-info "Starting game loop")
  (livesupport:setup-lisp-repl)
  (uiop:nest
   (with-system-config-options ((display-vsync display-fps)))
   (let* ((vsync display-vsync)
          (renderer (make-renderer))
          (last-tick (the double-float (al:get-time)))
          (last-repl-update last-tick)))
#+END_SRC

Next, we allocate [[https://liballeg.org/a5docs/trunk/events.html#allegro_event][liballegro event]] foreign structure with ~cffi:with-foreign-object~ macro and sleep for approximately 1/60 of a second so that the calculated FPS value for the very first frame does not cause division by zero. After that, we finally start the actual game loop with its body wrapped into ~restart-case~ for some nice restarts we'll discuss in a few moments.

#+NAME: game-loop-2
#+BEGIN_SRC lisp
   (cffi:with-foreign-object (event '(:union al:event))
     (sleep 0.016)
     (loop
       :do (restart-case
               (progn
#+END_SRC

First of all, in the beginning of every frame, we process the events. We first try to feed the allegro events we receive with [[https://liballeg.org/a5docs/trunk/events.html#al_get_next_event][~al:get-next-event~]] to the [[https://github.com/Immediate-Mode-UI/Nuklear/][Nuklear]] library using ~ui-handle-event~ helper in case some UI windows are active. In case the event is not handled by Nuklear, we call ~systems-handle-event~ helper we'll discuss in a moment. Also note that we can receive several events per frame, so we also use ~loop~ construct here.

#+NAME: game-loop-3
#+BEGIN_SRC lisp
                 (nk:with-input (ui-context)
                   (unless (loop :while (al:get-next-event event-queue event)
                                 :always (or (ui-handle-event event)
                                             (systems-handle-event event)))
                     (loop-finish)))
#+END_SRC

~ui-handle-event~ helper basically just feeds the event to the ~nk:allegro-handle-event~ function from [[https://gitlab.com/lockie/cl-liballegro-nuklear][cl-liballegro-nuklear]] wrapper library. The minor optimization here is that we don't do that if there are no active UI windows, which we determine by the call to ~ui-on-p~ function described in [[UI system]] section.

#+NAME: ui-handle-event
#+BEGIN_SRC lisp
(declaim
 #-d2c-debug (inline ui-handle-event)
 (ftype (function (cffi:foreign-pointer) boolean) ui-handle-event))
(defun ui-handle-event (event)
  (and (ui-on-p)
       (positive-fixnum-p (the fixnum (nk:allegro-handle-event event)))))
#+END_SRC

~systems-hande-event~ helper serves as a bridge between the low-level liballegro events and high-level in-game events described in detail in [[Events]] section. It calls ~make-allegro-event~ constructor function to make an instance of in-game event and then feeds that instance to all ECS systems; we'll talk more about what ECS is in [[ECS][corresponding section]]. Note that ~systems-handle-event~ returns ~nil~ only when the type of event is ~:display-close~, which is produced by liballegro when the game window is closed. This fact is used in the game loop to finish it.

#+NAME: systems-handle-event
#+BEGIN_SRC lisp
(declaim
 #-d2c-debug (inline systems-handle-event)
 (ftype (function (cffi:foreign-pointer) boolean) systems-handle-event))
(defun systems-handle-event (event)
  (let* ((type (cffi:foreign-slot-value event '(:union al:event) 'al::type))
         (allegro-event (make-allegro-event :type type :struct event)))
    ;; NOTE : processing allegro event without queueing, because event struct
    ;; is stack allocated
    (with-systems system
      (process-event system allegro-event))
    (not (eq type :display-close))))
#+END_src

You may notice weird ~inline~ declaration on both of the above helpers, effective only when ~:d2c-debug~ is present in ~*features*~. This kind of declaration appears in a lot of places of the engine. Its purpose is to allow inlining hot functions in release build for performance reasons, while having the ability to easily debug in the process of developing. So when you're working on d2clone-kit engine code or perhaps on your game's code based on the engine, you might want to do

#+BEGIN_SRC lisp
(pushnew :d2c-debug *features*)
#+END_SRC

in your REPL before ~quickload~'ing those.

Back to the game loop, after processing all low-level liballegro events, we separately process high-level events with ~process-events~ function, since the low-level event might trigger one or more high-level events and we don't want to deal with ordering issues.

After all of the events are processed, we do some time-based calculations. We get current frame's timestamp into the ~current-tick~ variable, check if we need to update livesupport REPL link with ~livesupport:update-repl-link~, calculate delta time between current frame and the previous one into the ~*delta-time*~ global variable and display FPS value if this is set in config.

#+NAME: game-loop-4
#+BEGIN_SRC lisp
                 (process-events)
                 (let ((current-tick (the double-float (al:get-time))))
                   (when (> (- current-tick last-repl-update)
                            repl-update-interval)
                     (livesupport:update-repl-link)
                     (setf last-repl-update current-tick))
                   (setf *delta-time* (- current-tick last-tick))
                   ;; TODO : draw FPS counter above the UI
                   (when display-fps
                     ;; TODO : smooth FPS counter, like in allegro examples
                     (add-debug-text :fps "FPS: ~d" (round 1 *delta-time*)))
#+END_SRC

Next, we call ~process-actions~ function which processes the actions related to every ECS system. Actions constitute separate framework used for multi-frame stateful actions performed by in-game entities; we'll cover those in detail in [[Actions][corresponding section]].

After that, we call ~system-update~ generic method in loop for every ECS system, which updates the aspects of the state of in-game entities being handled by those systems.

Further down the line, we call ~system-draw~ generic method which arranges the drawing commands needed for those state aspects to be drawn on screen with the ~renderer~ instance.

#+NAME: game-loop-5
#+BEGIN_SRC lisp
                   (process-actions)
                   ;; TODO : use separate threads for updating?..
                   (with-systems sys
                     ;; TODO : replace system-update with event?.. maybe even
                     ;; system-draw too?..
                     (system-update sys))
                   (with-systems sys
                     (system-draw sys renderer))
#+END_SRC

After those issues are handled, we proceed to actual drawing. We call [[https://liballeg.org/a5docs/trunk/graphics.html#al_clear_to_color][~al:clear-to-color~]] to flush the screen with the same black color, and then we call ~do-draw~ function which makes the functional renderer instance to do the actual draw calls. After swapping ~last-tick~ with ~current-tick~, we also call [[https://liballeg.org/a5docs/trunk/display.html#al_wait_for_vsync][~al:wait-for-vsync~]] if the vertical sync was set in config, and we call ~nk:allegro-render~ to render UI windows, if any. With that, we're finished with the draw calls, and we finally call [[https://liballeg.org/a5docs/trunk/display.html#al_flip_display][~al:flip-display~]] to swap drawing buffers.

#+NAME: game-loop-6
#+BEGIN_SRC lisp
                   (al:clear-to-color (al:map-rgb 0 0 0))
                   (do-draw renderer)
                   (setf last-tick current-tick))
                 (when vsync
                   (setf vsync (al:wait-for-vsync)))
                 (nk:allegro-render)
                 (al:flip-display))
#+END_SRC

At the bottom of the game loop body, we have a ~next-iteration~ restart, which allows to continue to the next iteration of loop when some condition arises within.

#+NAME: game-loop-7
#+BEGIN_SRC lisp
             ;; TODO restart to terminate the loop
             (next-iteration ()
               :report "Proceed to next game loop iteration."
               nil))))))
#+END_SRC

*** Game session

There are a couple more functions defined in =d2clone-kit.lisp= file, and they both are related to the game session and both called only from GUI scripts.

First one, ~new-game~ initializes a new game by recreating ~*session-entity*~, which is the parent of all entities created in the game session (we'll delve into entities in a few). It also clears the event queue.

#+NAME: new-game
#+BEGIN_SRC lisp
(defun new-game ()
  "Starts new game."
  (log-info "Starting new game")
  (when (entity-valid-p *session-entity*)
    (delete-entity *session-entity*))
  (growable-vector-clear *event-queue*)
  (setf (player-system-last-target *player-system*) +invalid-entity+)
  (setf *session-entity* (make-entity))
  (dolist (spec *new-game-object-specs*)
    (make-object spec *session-entity*)))
#+END_SRC

The second one, ~game-started-p~ returns boolean indicating whether there currently is an active gameplay session.

#+NAME: game-started-p
#+BEGIN_SRC lisp
(declaim
 #-d2c-debug (inline game-started-p)
 (ftype (function () boolean) game-started-p))
(defun game-started-p ()
  "Returns boolean indicating whether the game session is currently running."
  ;; HACK
  (entity-valid-p (player-system-entity *player-system*)))
#+END_SRC

** Logging

#+BEGIN_SRC lisp :tangle log.lisp :noweb yes :exports none
<<preamble>>

<<init-log>>

<<cfuns>>

<<defunl>>

<<last-message>>

<<trace-1>>
<<trace-2>>

<<deflog>>

<<with-condition-reporter>>
#+END_SRC

~init-log~ function first constructs the name of the log file, which would be =log.txt= residing in data directory. After that, it actually passes this file name to liballegro by setting the =ALLEGRO_TRACE= environment variable. Next, it tweaks a few logging parameters of liballegro. Namely, it (1) turns off the display of source code lines of log messages, because we can't reliably and easily get those in CL, and (2) it sets the log severity level, which by default is =info= and is being set in ~level~ optional argument to ~init-log~.

#+NAME: init-log
#+BEGIN_SRC lisp
(defun init-log (data-dir &optional (level "info"))
  (let ((log-file
          (merge-pathnames
           (make-pathname :name "log" :type "txt")
           data-dir)))
    ;; TODO : wait for liballegro 5.2.8 to release and then call
    ;;  al_register_trace_handler to handle output to both stdout & logfile
    (setf (uiop:getenv "ALLEGRO_TRACE")
          (namestring log-file)))
  (al:set-config-value (al:get-system-config) "trace" "lines" "0")
  (al:set-config-value (al:get-system-config) "trace" "level" level))
#+END_SRC

~%trace~ function is pivotal in the logging subsystem. It puts the messages with given severity level from Lisp side into liballegro log. To do that, it uses a couple of internal liballegro functions which are not a part of public interface. Therefore, we have to import those functions using CFFI:

#+NAME: cfuns
#+BEGIN_SRC lisp
(cffi:defcfun ("_al_trace_prefix" trace-prefix) :boolean
  (channel :string) (level :int) (file :string) (line :int) (function :string))

(cffi:defcfun ("_al_trace_suffix" trace-suffix) :void
  (msg :string) &rest)
#+END_SRC

The heavy lifting of logging is done by the ~do-trace~ local function, which first calls ~trace-prefix~ internal function we've imported, and if it succeeds, it calls ~trace-suffix~ further down; this is part of calling protocol of those functions. We add extra newline to the log message to be output, and after that we split it by 1024 byte portions, since this is the size of internal liballegro buffer, and if we don't do the splitting, the message will get truncated.

#+NAME: trace-1
#+BEGIN_SRC lisp
(defun %trace (level message args)
  (flet
      ((do-trace (level function-name message)
         (when (trace-prefix "d2clone-kit" level "" 0 function-name)
           (loop :with finalized-message := (format nil "~a~%" message)
                 :with length := (length finalized-message)
                 :for i :of-type fixnum :from 0 :to length :by 1024
                 :do (trace-suffix
                      "%s"
                      :string
                      (subseq finalized-message i (min length (+ i 1024))))))))
#+END_SRC

The ~%trace~ function first formats the arguments it has been given using the standard CL ~format~ function.

~%trace~ also features duplicate message detection which could be found in some popular logging utilities. It does that using the ~*last-message*~ and ~*last-message-repetitions*~ global variables defined above:

#+NAME: last-message
#+BEGIN_SRC lisp
(declaim (string *last-message*)
         (fixnum *last-message-repetitions*))
(global-vars:define-global-var *last-message* "")
(global-vars:define-global-var *last-message-repetitions* 0)
#+END_SRC

If the previous message was repeated more than once, before putting another message we add the line saying that /last message repeated/ that count of /times/.

After that, we finally put the actual log message along with the function name using ~do-trace~.

#+NAME: trace-2
#+BEGIN_SRC lisp
    (let ((full-message (apply #'format (list* nil message args))))
      (cond
        ((string= *last-message* full-message)
         (incf *last-message-repetitions*))
        (t
         (unless (zerop *last-message-repetitions*)
           (do-trace 1 "trace" (format nil "[last message repeated ~a times]"
                                       *last-message-repetitions*))
           (setf *last-message-repetitions* 0))
         (do-trace level (string-downcase *function-name*) full-message)
         (setf *last-message* full-message))))))
#+END_SRC

In C world, one can use [[https://gcc.gnu.org/onlinedocs/gcc/Function-Names.html][~__func__~]] macro to get the name of the current function. CL lacks that feature, so we had to implement it using our own ~defunl~ macro instead of standard ~defun~ for functions we want to see in log.

~defunl~ basically just puts the function name to the dynamic variable ~*function-name*~ right before the function body starts.

#+NAME: defunl
#+BEGIN_SRC lisp
(defvar *function-name* "")

(defmacro defunl (fname lambda-list &body body)
  "DEFUN wrapper which sets correct current function name for logging
functions."
  (let ((docstring (when (stringp (car body)) (pop body))))
    `(defun ,fname ,lambda-list
       ,@(ensure-list docstring)
       (let ((*function-name* (quote ,fname)))
         ,@body))))
#+END_SRC

This variable is being used to supply the function name to ~do-trace~ local function we've seen above, so that the names of Lisp functions can nicely appear in logs like that:

#+BEGIN_EXAMPLE
system      I al_install_system [   0.00000] Allegro version: 5.2.7
d2clone-kit I start-engine      [   0.00027] Starting d2clone-kit engine v0.1.2
d2clone-kit I init-fs           [   0.00031] Appending /home/andrew/Progs/GAMEDEV/d2clone-kit/Resources to mount points
#+END_EXAMPLE

Note that this mechanism might cause slowdown, so you probably don't want the functions called in tight loops to be defined with ~defunl~.

Finally, we don't use the ~%trace~ function itself throughout the engine codebase. Instead, we define a few wrappers for every log severity level supported by liballegro using the ~deflog~ macro, which just defines a small function with docstrings and everything wrapping ~%trace~ with the nice names like ~trace-debug~, ~trace-info~ etc.:

#+NAME: deflog
#+BEGIN_SRC lisp
(defmacro deflog (name level docstring)
  (let
      ((function-name (intern (concatenate 'string "LOG-" (symbol-name name)))))
    `(defun ,function-name (message &rest args)
       ,@(ensure-list docstring)
       (%trace ,level message args))))

(deflog debug 0
  "Adds formatted message MESSAGE using placeholder arguments ARGS to
  liballegro debug channel.")

(deflog info 1
  "Adds formatted message MESSAGE using placeholder arguments ARGS to
  liballegro info channel.")

(deflog warn 2
  "Adds formatted message MESSAGE using placeholder arguments ARGS to
  liballegro warn channel.")

(deflog error 3
  "Adds formatted message MESSAGE using placeholder arguments ARGS to
  liballegro error channel.")
#+END_SRC

** Filesystem

#+BEGIN_SRC lisp :tangle fs.lisp :noweb yes :exports none
<<preamble>>

<<physfs-defines>>

<<mount>>

<<enumerate-directory-callback>>

<<enumerate-directory-trampoline>>

<<enumerate-directory>>

<<init-fs>>

<<close-fs>>

<<prompt-for-string>>

<<ensure-loaded>>

<<sanitize-filename>>

<<read-file-into-list>>

<<character-stream>>

<<character-stream-initialize>>

<<character-stream-read-char>>

<<character-stream-read-sequence>>

<<character-stream-unget-char>>

<<binary-stream>>

<<binary-stream-initialize>>

<<binary-stream-element-type>>

<<binary-stream-read-byte>>

<<binary-stream-read-sequence>>

<<binary-stream-size>>

<<virtual-binary-stream>>

<<virtual-binary-stream-element-type>>

<<virtual-binary-stream-read-byte>>

<<virtual-binary-stream-read-sequence>>

<<read-binary>>

<<read-binary-methods>>

<<define-binary-struct>>
#+END_SRC

Liballegro features its own [[https://liballeg.org/a5docs/trunk/file.html][wrappers around C file I/O]] as well as [[https://liballeg.org/a5docs/trunk/physfs.html][integration]] with [[http://icculus.org/physfs/][PhysicsFS]] library. Despite the name, this library has nothing to do with physics simulation; it is rather a provider of uniform interface for various game archive formats, including, but not limited to, ZIP files, Quake™ PAK files, Doom™ WAD files etc.

We build upon this functionality, allowing the game resources to be loaded from ZIP files as if they were mere folders, instead of using separate files in real filesystem folders. This improves loading performance, especially on spinning hard disk drives. Also consider using zero compression level for ZIP files in your game projects for extra bit of performance upon loading.

In =fs.lisp= file we define lispish wrappers around liballegro file APIs using [[https://github.com/trivial-gray-streams/trivial-gray-streams][trivial-gray-streams]] library.

First of all, as liballegro documentation [[https://liballeg.org/a5docs/trunk/physfs.html][states]], one should set up PhysicsFS through its own API, so we start by defining all the necessary functions with CFFI.

On Windows, the PhysicsFS library is statically built into =allegro_physfs= DLL, so we don't need to worry about loading foreign library under that platform. On other OSes, PhysicsFS is usually a dependency of liballegro, installed separately, so we tell CFFI which file names of that library we expect.

After having foreign library stuff handled, we proceed to defining all the functions we'll need.

#+NAME: physfs-defines
#+BEGIN_SRC lisp
#-windows (progn
            (cffi:define-foreign-library libphysfs
              (:darwin (:or "libphysfs.3.0.2.dylib" "libphysfs.1.dylib"))
              (:unix (:or "libphysfs.so.3.0.2" "libphysfs.so.1"))
              (t (:default "libphysfs")))
            (cffi:use-foreign-library libphysfs))

(cffi:defcfun ("PHYSFS_init" physfs-init) :int (argv0 :string))
(cffi:defcfun ("PHYSFS_deinit" physfs-deinit) :int)
(cffi:defcfun ("PHYSFS_getLastError" physfs-get-last-error) :string)
(cffi:defcfun ("PHYSFS_permitSymbolicLinks" physfs-permit-symbolic-links) :void
  (allow :int))
(cffi:defcfun ("PHYSFS_getBaseDir" physfs-get-base-dir) :string)
(cffi:defcfun ("PHYSFS_setWriteDir" physfs-set-write-dir) :int
  (new-dir :string))
(cffi:defcfun ("PHYSFS_enumerateFilesCallback" physfs-enumerate) :int
  (dir :string) (callback :pointer) (data :pointer))
(cffi:defcfun ("PHYSFS_getRealDir" physfs-get-real-dir) :string
  (file-name :string))
(cffi:defcfun ("PHYSFS_mount" physfs-mount) :int
  (new-dir :string) (mount-point :string) (append-to-path :int))
#+END_SRC

Next, we define ~init-fs~ function which does all the necessary initialization. Namely, it calls [[https://icculus.org/physfs/docs/html/physfs_8h.html#a61b94cac8e65267afb8a5f2344e60dd1][physfs-init]] with the ~argv[0]~ argument it requires, obtained from the call to ~raw-command-line-arguments~ from UIOP.
Then we tweak PhysicsFS by allowing it to follow symbolic links with the call to [[https://icculus.org/physfs/docs/html/physfs_8h.html#aad451d9b3f46f627a1be8caee2eef9b7][physfs-permit-symbolic-links]].
Next, we set PhysicsFS /write dir/ to our data directory - that would be the only directory in which the engine would be able to write files, so all resources are basically read-only. To do that, we call [[https://icculus.org/physfs/docs/html/physfs_8h.html#a36c408d40b3a93c8f9fc02a16c02e430][physfs-set-write-dir]].
After that, we /mount/ several locations using helper function ~mount~, which is just a thin logging wrapper over [[https://icculus.org/physfs/docs/html/physfs_8h.html#a8eb320e9af03dcdb4c05bbff3ea604d4][physfs-mount]] - a function that adds a directory or archive path to [[http://icculus.org/physfs/docs/html/][PhysicsFS /search path/]], so that files from that dir or archive can be acessed by only specifying file name, without the full path:

#+NAME: mount
#+BEGIN_SRC lisp
(defun mount (path &key (append t))
  (let ((path-string
          (if (typep path 'pathname)
              (namestring path)
              path)))
    (log-info "~a ~a to mount points"
              (if append "Appending" "Prepending")
              path-string)
    (when (zerop (physfs-mount path-string (cffi:null-pointer) (if append 1 0)))
      (log-warn "...failed: ~a" (physfs-get-last-error)))))
#+END_SRC

In ~init-fs~, we first mount the directory =../Resources=. This choice of resources directory location is the consequence of the typical game folder layout [[https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFBundles/BundleTypes/BundleTypes.html#//apple_ref/doc/uid/10000123i-CH101-SW20][required on MacOS]] and suitable on other platforms: the binary is located in some subdirectory of the project (=MacOS= on MacOS and =bin= on other platforms), and the resources are located in =Resources= subdirectory:

#+BEGIN_EXAMPLE
.
├── Resources
│   └── assets.zip
└── bin
    ├── the-game
    └── liballegro.so.5.2
#+END_EXAMPLE

#+BEGIN_EXAMPLE
.
├── Resources
│   └── assets.zip
└── MacOS
    ├── the-game
    └── liballegro.5.2.dylib
#+END_EXAMPLE

This also makes sense for developing and running the game from the source tree, since it is expected from programmer to launch REPL from =src= subdirectory of the project:

#+BEGIN_EXAMPLE
.
├── Resources
│   └── assets.zip
├── src
│   └── d2clone-kit.lisp
└── d2clone-kit.asd
#+END_EXAMPLE

After mounting =Resources= directory, we proceed with mounting our data directory with PhysicsFS. Further down in ~init-fs~ we mount the directories from [[https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html][~$XDG_DATA_DIRS~]] in case the game is properly packaged into some binary package and the resources are located somewhere under =/usr/share= folder.

Finally, we enumerate all the files that are accessible by PhysicsFS and try to mount the files which name ends with =.zip=. We do that using ~enumerate-directory~ macro we'll discuss in a moment.

The last thing ~init-fs~ does is calling [[https://liballeg.org/a5docs/trunk/physfs.html#al_set_physfs_file_interface][~al:set-physfs-file-interface~]] which initializes integration between liballegro and PhysicsFS libraries.

#+NAME: init-fs
#+BEGIN_SRC lisp
(defunl init-fs (game-name data-dir)
  (when (zerop (physfs-init (first (uiop/image:raw-command-line-arguments))))
    (error "failed to initialize filesystem: ~a" (physfs-get-last-error)))
  (physfs-permit-symbolic-links 1)
  (when (zerop (physfs-set-write-dir (namestring data-dir)))
    (error "failed to initialize filesystem writing: ~a"
           (physfs-get-last-error)))
  (mount (merge-pathnames
          (truename
           (if (uiop:argv0)
               (merge-pathnames "../" (directory-namestring (uiop:argv0)))
               "../"))
          "Resources"))
  (mount data-dir)
  (dolist (dir (uiop/configuration:xdg-data-dirs))
    (mount
     (merge-pathnames
      (make-pathname :directory `(:relative ,game-name))
      dir)))
  (enumerate-directory "/"
    (when (uiop:string-suffix-p file ".zip")
      (mount (merge-pathnames (uiop:ensure-directory-pathname
                               (pathname (physfs-get-real-dir file)))
                              (pathname file)))))
  (al:set-physfs-file-interface))
#+END_SRC

There's also FS subsystem finalization function, ~close-fs~, which is again just a thin logging wrapper over [[https://icculus.org/physfs/docs/html/physfs_8h.html#aa465c9b58e5020f503085d433a413b5b][physfs-deinit]]:

#+NAME: close-fs
#+BEGIN_SRC lisp
(defunl close-fs ()
  (when (zerop (physfs-deinit))
    (log-error "failed to close filesystem: ~a" (physfs-get-last-error))))
#+END_SRC

~enumerate-directory~ is a macro allowing enumerating given PhysicFS directory. It is based on [[https://icculus.org/physfs/docs/html/physfs_8h.html#a33085cbbf18ba7eb659cf2a43d6793ba][physfs-enumerate]] function taking the callback parameter. Since we don't want users of this funciton to meddle with such low-level details, we put macro body into the function with two ignorable arguments, ~directory~ and ~file~, and set this function to the dynamic variable ~*enumerate-directory-callback*~:

#+NAME: enumerate-directory-callback
#+BEGIN_SRC lisp
(declaim (type (function (string string)) *enumerate-directory-callback*))
(defvar *enumerate-directory-callback*)
#+END_SRC

We then use this variable in CFFI callback called ~enumerate-directory-trampoline~ which basically just ~funcall~'s the function:

#+NAME: enumerate-directory-trampoline
#+BEGIN_SRC lisp
(cffi:defcallback enumerate-directory-trampoline :int
    ((data :pointer) (directory :string) (file :string))
  (declare (ignore data))
  (funcall *enumerate-directory-callback* directory file))
#+END_SRC

This trampoline actually gets passed to PhysicsFS C API using [[https://common-lisp.net/project/cffi/manual/html_node/callback.html][~cffi:callback~]]:

#+NAME: enumerate-directory
#+BEGIN_SRC lisp
;; TODO : perhaps add required extension optional/keyword arg
(defmacro enumerate-directory (dir &body body)
  "Enumerates directory DIR. Executes BODY for each file with corresponding
variables DIRECTORY and FILE bound."
  (let ((callback-name (gensym "ENUMERATE-DIRECTORY-CALLBACK")))
    `(progn
       (defun ,callback-name (directory file)
         (declare (type string directory file) (ignorable directory file))
         ,@body
         1)
       (let ((*enumerate-directory-callback* #',callback-name))
         (physfs-enumerate ,dir
                           (cffi:callback enumerate-directory-trampoline)
                           (cffi:null-pointer))))))
#+END_SRC

Next, there are a few file-related helpers defined in =fs.lisp=.

First, there's ~ensure-loaded~ helper used to handle loading of different CFFI resources. It could be used with any C function returning ~NULL~ on failure. The function is passed through ~load-fn~ argument, and the file name in ~file-name~ argument along with any rest arguments are just passed to that function. Typical examples of such functions are [[https://liballeg.org/a5docs/trunk/graphics.html#al_load_bitmap][~al:load-bitmap~]] and [[https://liballeg.org/a5docs/trunk/audio.html#al_load_sample][~al:load-sample~]]. In case of success, the non-~NULL~ result is just returned from the ~ensure-loaded~ helper. In case of failure, we signal a condition indicating it, and we present user with few handy restarts. The first one, ~specify-filename~, just calls ~ensure-loaded~ again, but with the new file name specified by user; we receive the new name with simple ~prompt-for-string~ helper:

#+NAME: prompt-for-string
#+BEGIN_SRC lisp
(declaim (ftype (function (string) string) prompt-for-string))
(defun prompt-for-string (prompt)
  "Prompts for a string value from *QUERY-IO*. To be used with interactive
restarts."
  (format *query-io* prompt)
  (force-output *query-io*)
  (read-line *query-io*))
#+END_SRC

The next restart, ~retry-loading~, just retries the loading with the same arguments.

#+NAME: ensure-loaded
#+BEGIN_SRC lisp
(declaim (ftype (function (function string &rest t) cffi:foreign-pointer)
                ensure-loaded))
(defun ensure-loaded (load-fn file-name &rest rest)
  "Calls LOAD-FN (which could be #'AL:LOAD-BITMAP, #'AL:LOAD-SAMPLE or
similar) with the FILE-NAME argument and REST arguments, if any.  If the
result of calling of LOAD-FN is not a null pointer, it is returned. Otherwise
the error is raised, with interactive restart allowing to specify another
filename."
  (values
   (restart-case
       (let ((file (apply load-fn file-name rest)))
         (if (cffi:null-pointer-p file)
             (error "failed to load '~a'" file-name)
             file))
     (specify-filename (new-file-name)
       :report "Specify another file name."
       :interactive (lambda ()
                      (list
                       (prompt-for-string
                        "Please specify another file name: ")))
       (apply #'ensure-loaded load-fn new-file-name rest))
     (retry-loading ()
       :report "Retry loading."
       (apply #'ensure-loaded load-fn file-name rest)))))
#+END_SRC

Next, there's a little ~sanitize-filename~ helper used to remove the characters from a string that are forbidden in file names on common filesystems. It uses [[http://edicl.github.io/cl-ppcre][cl-ppcre]] regular expression library to achieve that:

#+NAME: sanitize-filename
#+BEGIN_SRC lisp
(declaim
 #-d2c-debug (inline sanitize-filename)
 (ftype (function (string) string) sanitize-filename))
(defun sanitize-filename (filename)
  (values (cl-ppcre:regex-replace-all
           "\\x22|\\x2a|\\x2f|\\x3a|\\x3c|\\x3e|\\x3f|\\x5c|\\x7c" filename
           "")))
#+END_SRC

Also there's ~read-file-into-list~ helper that's used to read the whole text file from resources into Lisp list. This helper is very similar to [[https://common-lisp.net/project/asdf/uiop.html#index-read_002dfile_002dlines][~uiop:read-file-lines~]], but it possesses the ability to read files within PhycisFS virtual filesystem, including reading files from ZIP archives. To achieve that, it uses [[https://liballeg.org/a5docs/trunk/file.html#al_fopen][~al:fopen~]] and [[https://liballeg.org/a5docs/trunk/file.html#al_fgets][~al:fgets~]] along with some [[https://common-lisp.net/project/cffi/manual/html_node/Strings.html][CFFI string manipulaton functions]]:

#+NAME: read-file-into-list
#+BEGIN_SRC lisp
(declaim
 (ftype (function (string &key (:buffer-length fixnum)) list)
        read-file-into-list))
(defun read-file-into-list (pathname &key (buffer-length 4096))
  "Reads text file specified by PATHNAME into a list line-by-line.
Lines are expected to be shorter than BUFFER-LENGTH chars."
  (cffi:with-foreign-object (buffer :char buffer-length)
    (loop
      :with file := (al:fopen (namestring pathname) "r")
        :initially (when (cffi:null-pointer-p file) (return nil))
      :for line := (al:fgets file buffer buffer-length)
      :until (cffi:null-pointer-p line)
      :collecting
      (flet ((trim (str) (subseq str 0 (1- (length str)))))
        (trim (cffi:foreign-string-to-lisp line)))
      :finally (al:fclose file))))
#+END_SRC

There's an important consequence of using such low-level C APIs, namely - the lines in the file should be shorter than ~buffer-length~, which is 4k bytes by default, otherwise it'll get truncated.

*** Binary file struct helpers

Further down, there are a few helpers for defining and reading structures from binary files. Those center around the ~define-binary-struct~ macro which acts similar to standard [[http://www.lispworks.com/documentation/lw70/CLHS/Body/m_defstr.htm][~defstruct~]] macro. The supported types for the ~:type~ parameter of the field are: ~'byte~, ~'word~, ~'dword~, ~'string~ and ~'bytes~. Also you could supply ~:length~ parameter to field plist to specify the length of this field in units of its type. This macro defines a structure with an actual ~defstruct~ call and then defines a ~read-binary~ generic method, which we'll describe in a moment, specializing on this structure:

#+NAME: define-binary-struct
#+BEGIN_SRC lisp
(defmacro define-binary-struct (name &rest slots)
  "Defines structure with name NAME and slots SLOTS along with corresponding
READ-BINARY method which reads and returns that structure from given binary
stream.

See READ-BINARY"
  (flet
      ((slot->struct-slot (spec)
         (let* ((parameters (cdr spec))
                (type (eval (getf parameters :type)))
                (lisp-type (ecase type
                             ((byte word dword) 'fixnum)
                             (string 'string)
                             (bytes 't)))
                (initial (ecase type
                           ((byte word dword) 0)
                           (string "")
                           (bytes nil))))
           `(,(car spec) ,initial :type ,lisp-type :read-only t)))
       (slot->slot-ctor (spec)
         (let* ((parameters (cdr spec))
                (type (getf parameters :type))
                (length (getf parameters :length)))
           `(,(make-keyword (car spec))
             (read-binary ,(if length length type) stream)))))
    `(progn
       (defstruct ,name
         ,@(mapcar #'slot->struct-slot slots))
       (defmethod read-binary ((type (eql ',name)) stream)
         (,(symbolicate :make- name)
          ,@(mapcan #'slot->slot-ctor slots))))))
#+END_SRC

To have a look at the actual usage of that macro, refer to [[Aseprite format support]].

The ~read-binary~ generic method takes the ~type~ argument, one of field types mentioned above or some structure defined with ~define-binary-struct~, and the binary stream to read from. Also the ~fixnum~ passed as the ~type~ argument is interpreted as the number of bytes to read.

#+NAME: read-binary
#+BEGIN_SRC lisp
(defgeneric read-binary (type stream)
  (:documentation "Reads and returns element of type denoted by TYPE from
  binary stream STREAM."))
#+END_SRC

Further down, this method is specialized for all of supported field types:

#+NAME: read-binary-methods
#+BEGIN_SRC lisp
(defmethod read-binary ((type (eql 'byte)) stream)
  (read-byte stream))

;; TODO : use Zach Beane's trick: (logand x #xFFFFFFFF) removes the need
;;  of declaring x to be fixnum

(defmethod read-binary ((type (eql 'word)) stream)
  (let ((word 0))
    (setf (ldb (byte 8 0) word) (read-byte stream))
    (setf (ldb (byte 8 8) word) (read-byte stream))
    word))

(defmethod read-binary ((type (eql 'dword)) stream)
  (let ((dword 0))
    (setf (ldb (byte 8 0) dword) (read-byte stream))
    (setf (ldb (byte 8 8) dword) (read-byte stream))
    (setf (ldb (byte 8 16) dword) (read-byte stream))
    (setf (ldb (byte 8 24) dword) (read-byte stream))
    dword))

(defmethod read-binary ((length fixnum) stream)
  (let ((string (make-array length :element-type '(unsigned-byte 8))))
    (read-sequence string stream)
    string))
#+END_SRC


Finally, there are few helper [[http://www.nhplace.com/kent/CL/Issues/stream-definition-by-user.html][Gray streams]] defined in =fs.lisp=.

*** Character stream

First of those is textual ~character-stream~:

#+NAME: character-stream
#+BEGIN_SRC lisp
(defclass character-stream
    (trivial-gray-streams:fundamental-character-input-stream)
  ((path :initarg :path :initform (error "missing path"))
   (al-file))
  (:documentation "Wrapper around liballegro
[file APIs](https://liballeg.org/a5docs/trunk/file.html)."))
#+END_SRC

It has the initial path name supplied by user, ~path~, and the CFFI pointer returned from [[https://liballeg.org/a5docs/trunk/file.html#al_fopen][~al:fopen~]], ~al-file~ as slots.

We define ~initialize-instance~ ~:after~ method which handles file opening failure by signaling the condition:

#+NAME: character-stream-initialize
#+BEGIN_SRC lisp
(defmethod initialize-instance :after ((stream character-stream) &key)
  (with-slots (path al-file) stream
    (setf al-file (al:fopen path "r"))
    (when (cffi:null-pointer-p al-file)
      (error "failed to open '~a'" path))))
#+END_SRC

Then we define ~stream-read-char~ for the character stream, which is a trivial wrapper over [[https://liballeg.org/a5docs/trunk/file.html#al_fgetc][~al:fgetc~]], with additional error checking by the call to [[https://liballeg.org/a5docs/trunk/file.html#al_feof][~al:feof~]], namely, if the former returns negative value, we check if it was related to the end-of-file, and if not, we signal a condition:

#+NAME: character-stream-read-char
#+BEGIN_SRC lisp
(defmethod trivial-gray-streams:stream-read-char ((stream character-stream))
  (with-slots (path al-file) stream
    (let ((char (al:fgetc al-file)))
      (if (minusp char)
          (if (al:feof al-file)
              :eof
              (error "error reading '~a': ~a" path (al:ferrmsg al-file)))
          (code-char char)))))
#+END_SRC

We also define ~stream-read-sequence~ specialized on ~character-stream~, which again is a wrapper around [[https://liballeg.org/a5docs/trunk/file.html#al_fread][~al:fread~]]. Again, we do error checking by calling [[https://liballeg.org/a5docs/trunk/file.html#al_ferror][~al:ferror~]] and signaling a condition if it reports some error.

#+NAME: character-stream-read-sequence
#+BEGIN_SRC lisp
(defmethod trivial-gray-streams:stream-read-sequence ((stream character-stream)
                                                      sequence start end
                                                      &key &allow-other-keys)
  (declare (type non-negative-fixnum start end))
  (with-slots (path al-file) stream
    (let* ((length (- end start))
           actual-length
           (result
             (cffi:with-foreign-pointer-as-string (buffer length
                                                          :count actual-length)
               (setf actual-length (al:fread al-file buffer length))
               (when (al:ferror al-file)
                 (error "error reading '~a': ~a" path (al:ferrmsg al-file))))))
      (replace sequence result :start1 start :end1 end)
      actual-length)))
#+END_SRC

Finally, we define ~stream-unread-char~ for the character stream, which is just a thin wrapper over [[https://liballeg.org/a5docs/trunk/file.html#al_fungetc][al:fungetc]]:

#+NAME: character-stream-unget-char
#+BEGIN_SRC lisp
(defmethod trivial-gray-streams:stream-unread-char ((stream character-stream)
                                                    char)
  (with-slots (path al-file) stream
    (al:fungetc al-file (char-code char))))
#+END_SRC

*** Binary stream

The next stream type is also based on liballegro file APIs, but is intended to use with binary files. It shares the same slots with the ~character-stream~, ~path~ and ~al-file~:

#+NAME: binary-stream
#+BEGIN_SRC lisp
(defclass binary-stream (trivial-gray-streams:fundamental-binary-input-stream)
  ((path :initarg :path :initform (error "missing path"))
   (al-file))
  (:documentation "Wrapper around liballegro
[file APIs](https://liballeg.org/a5docs/trunk/file.html)."))
#+END_SRC

~initialize-instance~ ~:after~ method for ~binary-stream~ only differs from similar method of ~character-stream~ by using ~"rb"~ opening method in call to [[https://liballeg.org/a5docs/trunk/file.html#al_fopen][al:fopen]]:

#+NAME: binary-stream-initialize
#+BEGIN_SRC lisp
(defmethod initialize-instance :after ((stream binary-stream) &key)
  (with-slots (path al-file) stream
    (setf al-file (al:fopen path "rb"))
    (when (cffi:null-pointer-p al-file)
      (error "failed to open '~a'" path))))
#+END_SRC

It is important to setup Gray stream's character type since we're using binary data. We do that by specializing ~stream-element-type~ generic method:

#+NAME: binary-stream-element-type
#+BEGIN_SRC lisp
(defmethod stream-element-type ((stream binary-stream))
  '(unsigned-byte))
#+END_SRC

Then we define ~stream-read-byte~, which implementation is almost identical to the ~stream-read-char~ for ~character-stream~ in a sense that it calls the same liballegro file APIs:

#+NAME: binary-stream-read-byte
#+BEGIN_SRC lisp
(defmethod trivial-gray-streams:stream-read-byte ((stream binary-stream))
  (with-slots (path al-file) stream
    (let ((char (al:fgetc al-file)))
      (if (minusp (the fixnum char))
          (if (al:feof al-file)
              :eof
              (error "error reading '~a': ~a" path (al:ferrmsg al-file)))
          char))))
#+END_SRC

Next, we define ~stream-read-sequence~ for ~binary-stream~ which uses [[https://liballeg.org/a5docs/trunk/file.html#al_fread][~al:fread~]] and enjoys some features of CFFI, namely [[https://www.crategus.com/books/cffi/pages/cffi-sys_fun_with-pointer-to-vector-data.html][~cffi:with-pointer-to-vector-data~]] which allows to put some binary data straight into a Lisp vector of bytes, omitting any extra copying:

#+NAME: binary-stream-read-sequence
#+BEGIN_SRC lisp
(defmethod trivial-gray-streams:stream-read-sequence ((stream binary-stream)
                                                      sequence start end
                                                      &key &allow-other-keys)
  (declare (type non-negative-fixnum start end))
  (with-slots (path al-file) stream
    (cffi:with-pointer-to-vector-data (buffer sequence)
      (let ((pointer (cffi:inc-pointer buffer start)))
        ;; TODO : test for error
        (+ start (al:fread al-file pointer (- end start)))))))
#+END_SRC

And last but not least, we specify ~stream-size~ method for ~binary-stream~, which just calls [[https://liballeg.org/a5docs/trunk/file.html#al_fsize][~al:fsize~]]:

#+NAME: binary-stream-size
#+BEGIN_SRC lisp
(defun stream-size (stream)
  "Returns the file size of BINARY-STREAM and CHARACTER-STREAM.

See BINARY-STREAM
See CHARACTER-STREAM"
  (with-slots (al-file) stream
    (al:fsize al-file)))
#+END_SRC

*** Virtual binary stream

The last Gray stream type we define is read-only ~virtual-binary-stream~, which is backed by an array of bytes:

#+NAME: virtual-binary-stream
#+BEGIN_SRC lisp
(defclass virtual-binary-stream
    (trivial-gray-streams:fundamental-binary-input-stream)
  ((buffer :initarg :buffer :initform (error "missing buffer"))
   (position :initform 0))
  (:documentation "Read-only binary Gray stream based on SIMPLE-ARRAY of
  UNSIGNED-BYTE."))
#+END_SRC

We also specify the element type of this stream by specializing ~stream-element-type~ on it, since it is also binary:

#+NAME: virtual-binary-stream-element-type
#+BEGIN_SRC lisp
(defmethod stream-element-type ((stream virtual-binary-stream))
  '(unsigned-byte))
#+END_SRC

Then we define ~stream-read-byte~, which basically retrieves the byte by the stream's current position with [[http://www.lispworks.com/documentation/HyperSpec/Body/f_elt.htm][~elt~]] and then advances the position:

#+NAME: virtual-binary-stream-read-byte
#+BEGIN_SRC lisp
(defmethod trivial-gray-streams:stream-read-byte ((stream
                                                   virtual-binary-stream))
  (with-slots (buffer position) stream
    (declare (type (simple-array (unsigned-byte 8)) buffer)
             (type non-negative-fixnum position))
    (elt buffer (prog1 position (incf position)))))
#+END_SRC

And finally, we specialize ~stream-read-sequence~ on ~virtual-binary-stream~, which uses [[http://www.lispworks.com/documentation/HyperSpec/Body/f_replac.htm][~replace~]] to copy the requested range of bytes:

#+NAME: virtual-binary-stream-read-sequence
#+BEGIN_SRC lisp
(defmethod trivial-gray-streams:stream-read-sequence ((stream
                                                       virtual-binary-stream)
                                                      sequence start end
                                                      &key &allow-other-keys)
  (with-slots (buffer position) stream
    (declare (type (simple-array (unsigned-byte 8)) sequence buffer)
             (type non-negative-fixnum position start end))
    (replace sequence buffer :start1 start :end1 end :start2 position)
    (let ((copied (min (- end start) (- (length buffer) position))))
      (+ start (incf position copied)))))
#+END_SRC

** Config

#+BEGIN_SRC lisp :tangle config.lisp :noweb yes :exports none
<<preamble>>

<<global-config>>

<<init-config>>

<<save-config>>

<<config-setter>>

<<config-getter>>

<<close-config>>

<<defoptions>>

<<system-options>>
#+END_SRC

Config subsystem, while piggybacking on top of [[https://liballeg.org/a5docs/trunk/config.html][liballegro facilities]], provides nice lispy interface to serialize global configuration options. Each of these options have so called /section/, so they're basically organized into simple one-level hierarchy. We'll return to this hierarchy in a moment.

Now first of all, there's global liballegro [[https://liballeg.org/a5docs/trunk/config.html#allegro_config][configuration structure]] called ~*config*~ and used to store everything we need:

#+NAME: global-config
#+BEGIN_SRC lisp
(declaim (type cffi:foreign-pointer *config*))
(global-vars:define-global-var *config* (cffi:null-pointer))
#+END_SRC

~init-log~ function, called in ~run-engine~, just uses [[https://liballeg.org/a5docs/trunk/config.html#al_load_config_file][~al:load-config-file~]] to try and load config from =config.ini= file in data directory. Note that the location of data directory is obtained by liballegro itself using the game name, that's why it is important to call [[https://liballeg.org/a5docs/trunk/system.html#al_set_app_name][~al:set-app-name~]] before calling ~init-log~.
If ~init-log~ fails to load aforementioned file, it just creates an empty configuration structure with the call to [[https://liballeg.org/a5docs/trunk/config.html#al_create_config][~al:create-config~]].

#+NAME: init-config
#+BEGIN_SRC lisp
(defun init-config ()
  (setf *config* (al:load-config-file "config.ini"))
  (when (cffi:null-pointer-p *config*)
    (setf *config* (al:create-config))))
#+END_SRC

There's also an evil twin of ~init-config~, called ~close-config~ and used to finalize config subsystem:

#+NAME: close-config
#+BEGIN_SRC lisp
(defun close-config ()
  (save-config)
  (al:destroy-config *config*)
  (setf *config* (cffi:null-pointer)))
#+END_SRC

It just saves the config with the call to ~save-config~, destroys the global variable ~*config*~ with the call to [[https://liballeg.org/a5docs/trunk/config.html#al_destroy_config][~al:destroy-config~]] and sets it to ~NULL~ pointer to prevent use-after-free memory errors.

~save-config~, in turn, is a simple wrapper over [[https://liballeg.org/a5docs/trunk/config.html#al_save_config_file][~al:save-config-file~]] which just saves configuration data to the file with predefined name =config.ini= (note: it is written by liballegro to the data directory):

#+NAME: save-config
#+BEGIN_SRC lisp
(declaim #-d2c-debug (inline save-config))
(defun save-config ()
  (al:save-config-file "config.ini" *config*))
#+END_SRC

Next, there are two functions which are keystone to config subsystem interface, namely the getter and the setter of options.

The getter, simply called ~config~, first calls [[https://liballeg.org/a5docs/trunk/config.html#al_get_config_value][~al:get-config-value~]] on global ~*config*~ instance to get the configuration option value with supplied section name and option name - both expected to be keywords and both are, of course, converted to string before passing to C API. Note that section could be ~nil~, so that there could be sectionless options.
If the requested value was found, it is being converted to Lisp value with the call to ~read-from-string~, so we can have various Lisp data in config, including, but not limited to lists, for example it is possible to notice something like the following in the config file:

#+BEGIN_EXAMPLE
[DEBUG]
CURSOR=(0 0 255)
#+END_EXAMPLE

which is the list of three elements 0, 0 and 255 in the option named ~:cursor~ under the section named ~:debug~.

If, on the other hand, the requested value was not found, we take the optional default value supplied to the call to ~config~ and set it to configuration calling setter, ~(setf config)~. That's an important feature, and it has two important consequences: (1) while trying to simply get the config option value, there could be underlying disk write to set the previously unset default value, at least for the first time, and (2) even if the config file didn't exist before starting the engine, it would appear afterwards, filled with the default values.

#+NAME: config-getter
#+BEGIN_SRC lisp
(declaim
 (ftype (function ((or keyword null) keyword &optional t) t) config))
(defun config (section key &optional default)
  (if-let (value (al:get-config-value
                  *config* (string (or section :||)) (string key)))
    (read-from-string value)
    (setf (config section key) default)))
#+END_SRC

Now to the option setter, which is being defined as custom ~setf~ place, namely ~(setf config)~. It also takes the option name and optional section name, also converts those to strings and calls [[https://liballeg.org/a5docs/trunk/config.html#al_set_config_value][~al:set-config-value~]] to set the supplied value (converted to the string by the call to ~write-to-string~). After that, it calls ~save-config~ to write updated ~*config*~ structure to disk.

#+NAME: config-setter
#+BEGIN_SRC lisp
(declaim
 (ftype (function (t (or keyword null) keyword) t) (setf config)))
(defun (setf config) (value section key)
  (al:set-config-value
   *config* (string (or section :||)) (string key)
   (write-to-string value))
  (save-config)
  value)
#+END_SRC

Finally, there's a macro called ~defoptions~ used to create a pre-defined set of configuration options along with a nice macro to access those by just specifying their names instead of typing a lot of boilerplate code involving getter and setter described above.
This macro is somewhat similar to the standard ~defstruct~: you specify the name of the set, then you enumerate configuration options, specifically option name, section name, Lisp type and default value, and the macro does the rest. There's nothing more to say about it, except that it involves a bit of semi-complex macro trickery, namely defining a macro within a macro:

#+NAME: defoptions
#+BEGIN_SRC lisp
;; TODO : come up with some sort of caching to global var, calling
;; al_get_config_value is not free
(defmacro defoptions (name &rest options)
  "Defines macro to access given group of options. E.g. when NAME is 'SYSTEM,
it defines WITH-SYSTEM-CONFIG-OPTIONS macro. OPTIONS should be list of lists
containing option's section name, option's name, and :TYPE and :DEFAULT
properties.

See WITH-SYSTEM-CONFIG-OPTIONS"
  (let* ((section-names (mapcar #'car options))
         (key-names (mapcar #'cadr options))
         (option-names (mapcar #'(lambda (s k) (symbolicate s :- k))
                               section-names key-names))
         (option-types (mapcar #'(lambda (o) (getf o :type)) options))
         (option-defaults (mapcar #'(lambda (o) (getf o :default)) options))
         (let-clauses (mapcar
                       #'(lambda (o s k type d)
                           `(,o . ((the ,type
                                        (config ,(make-keyword s)
                                                ,(make-keyword k)
                                                ,d)))))
                       option-names section-names key-names
                       option-types option-defaults)))
    `(defmacro ,(symbolicate :with- name :-config-options) ((options
                                                             &key (read-only t))
                                                            &body body)
       "Executes BODY with bindings for config options OPTIONS. If READ-ONLY is
T (the default), options are not SETF-able."
       (let ((let-clauses
               (remove-if-not
                #'(lambda (c) (find (car c) options))
                '(,@let-clauses))))
         `(,(if read-only 'let 'symbol-macrolet) (,@let-clauses)
           ,@body)))))
#+END_SRC

Let's jump to this macro's usage example, which defines a set of so-called **system config options** used throughout the engine. For now, it just includes two sections: =display=, related to rendering options, and =debug= related to various debugging helpers.

#+NAME: system-options
#+BEGIN_SRC lisp
(defoptions system
  (display width :type fixnum :default 800)
  (display height :type fixnum :default 600)
  (display windowed :type boolean :default t)
  (display vsync :type boolean :default nil)
  (display fps :type boolean :default nil)
  (display multisampling :type fixnum :default 0)
  (display font :type string :default "font.ttf")
  (debug grid :type list :default nil)
  (debug sprite :type list :default nil)
  (debug cursor :type list :default nil)
  (debug path :type list :default nil)
  (debug collisions :type list :default nil)

  )
#+END_SRC

This macro invocation defines the macro ~with-system-config-options~, which is again somewhat similar to standard ~with-slots~ macro in a sense that it allows to write something like this:

#+BEGIN_SRC lisp
(with-system-config-options ((display-width display-height))
  (format t "screen size is ~a x ~a~%" display-width display-height))
#+END_SRC

** Data tables

#+BEGIN_SRC lisp :tangle data-tables.lisp :noweb yes :exports none
<<preamble>>

<<global-data-tables>>

<<build-data-table>>

<<table-indices>>

<<build-data-tables>>

<<load-data-tables>>

<<table-value-ref>>

<<table-value-ref*>>
#+END_SRC

Next stop is data tables, which are the databases where the engine looks for game-specific data. The file format it uses to store those databases is compatible with [[http://castledb.org][CastleDB]] editor and basically is just a JSON with pre-defined model. The data read from those databases is organized in the way that allows for fast row access using index columns (which are also pre-defined for every table). This data is stored in global variable ~*data-tables*~, which is a hashtable keyed by the keywords representing table names:

#+NAME: global-data-tables
#+BEGIN_SRC lisp
(declaim (type hash-table *data-tables*))
(global-vars:define-global-var *data-tables* (make-hash :test #'eq)
  "Global data tables read from CastleDB resource files.")
#+END_SRC

Next, there's a global constant called ~+table-indices+~, which stores the specifications of tables known to the engine:

#+NAME: table-indices
#+BEGIN_SRC lisp
(define-constant +table-indices+
    '(:impact-sounds ((:armor-class :weapon-class) (:sound))
      )
  :test #'equal
  :documentation "Specifies the columns to be included in indices for data
  tables. It is assumed that the columns list is alphabetically sorted.")
#+END_SRC

~+table-indices+~ is a plist, in which keys reference the table name and values are the lists specifying the columns. Namely, the first element in that list should be another list consisting of the index column names in **alphabetical order**. The second element should be also a list containing all the other columns.

The ~load-data-tables~ function called from ~run-engine~ just enumerates the =tables/= subdirectory in resources, trying to find any files there with =.cdb= extension, with the help of ~enumerate-directory~ macro we've seen previously. Next, it uses ~load-castledb-tables~ function we'll describe in the next section, called with the ~character-stream~ instance to deserialize the data from the JSON. After that, we have some awkward ~loop~ to figure out database file priorities (refer to [[CastleDB format support]] for details). Finally, this function calls ~build-data-tables~ with all of the gathered data and custom table indices specification it was supplied with in ~table-indices~ argument. The final result is stored in ~*data-tables*~ variable we've seen before.

#+NAME: load-data-tables
#+BEGIN_SRC lisp
(defunl load-data-tables (table-indices)
  "Loads all possible data from CastleDB files, considering table priorities.
Afterwards, builds all the appropriate indices and sets *DATA-TABLES*
accordingly.

See *DATA-TABLES*"
  (let ((all-tables (make-hash :test #'eq))
        (all-priorities (make-hash :test #'eq)))
    (enumerate-directory "tables"
      (when (uiop:string-suffix-p file ".cdb")
        (log-info "Loading data table ~a" file)
        (multiple-value-bind (tables priorities)
            (load-castledb-tables
             (make-instance 'character-stream
                            :path (namestring
                                   (make-pathname
                                    :defaults (pathname file)
                                    :directory `(:relative ,directory)))))
          (loop :for table-name :being :the :hash-key
                :using (hash-value rows) :of tables
                :for priority := (gethash table-name priorities)
                :do (multiple-value-bind (old-priority existing)
                        (gethash table-name all-priorities)
                      (when (or (not existing)
                                (< old-priority priority))
                        (setf
                         (gethash table-name all-tables) rows
                         (gethash table-name all-priorities) priority)))))))
    (setf *data-tables* (build-data-tables all-tables table-indices))))
#+END_SRC

The ~build-data-tables~ function takes care of organizing the data according to the indices specification it was given. First, it tries to merge that ~table-indices~ specifications with global ~+table-indices+~ constant we've discussed previously. Next, it just iterates over all of the tables it was given (since ~data~ argument is just a hashtable with table names as keys and plists of rows as values) and just feeds the row data to ~build-data-table~ function, which does the job of organizing the data for a single table.

#+NAME: build-data-tables
#+BEGIN_SRC lisp
(declaim (ftype (function (hash-table list)) build-data-tables))
(defunl build-data-tables (data table-indices)
  "Builds data table indices for given DATA and TABLE-INDICES

See +TABLE-INDICES+"
  (loop :with indices := (append +table-indices+ table-indices)
        :with result := (make-hash :test #'eq)
        :for count :of-type fixnum :from 0
        :for designator :being :the :hash-key
        :using (hash-value table) :of data
        :for (index-columns value-columns) := (getf indices designator)
        :do (setf (gethash designator result)
                  (build-data-table table index-columns value-columns))
        :finally (log-info "~d data table(s) built" count)
        :finally (return result)))
#+END_SRC

~build-data-table~ function transforms the list of rows represented as plists into a single hashtable, in which the keys are the plists of index columns, and the values are either singular values or a plists of all of the other columns. To demonstrate, let's have a look at the contents of =:impact-sounds= table that's used in the engine:

#+BEGIN_EXAMPLE
D2C> (hash-table-plist (gethash :impact-sounds *data-tables*))
((:ARMOR-CLASS :BONE :WEAPON-CLASS :SWORD)
 :SWORD-BONE
 (:ARMOR-CLASS :BONE :WEAPON-CLASS :DAGGER)
 :DAGGER-BONE
 (:ARMOR-CLASS :BONE :WEAPON-CLASS :FISTS)
 :FISTS-BONE
;; ...
#+END_EXAMPLE

Since we use index column values as keys in the resulting hashtable, it should be obvious that the index column values should be unique, as it always is in relational databases.

#+NAME: build-data-table
#+BEGIN_SRC lisp
(declaim (ftype (function (list list list) hash-table) build-data-table))
(defun build-data-table (table index-columns value-columns)
  (loop :with result := (make-hash :test #'equal)
        :for row :in table
        :for indices := (mapcan
                         #'(lambda (column) (list column (getf row column)))
                         index-columns)
        for values := (if (length= 1 value-columns)
                          (getf row (first value-columns))
                          (mapcan
                           #'(lambda (column) (list column (getf row column)))
                           value-columns))
        :do (setf (gethash indices result) values)
        :finally (return result)))
#+END_SRC

Finally, we have a couple of accessors for the table data. They're not accessors per se, rather the getters, since the table data is read-only once it is loaded.

The first one, ~table-value-ref~, just accesses the data table's hashtable described above. It takes ~table-designator~ argument as a keyword, and plist of ~predicates~ which relate to index column(s). It can return specified ~default~ value instead of ~nil~ when the column is not found, and it can return only a single column value instead of full plist when supplied with ~column~ keyword argument.

#+NAME: table-value-ref
#+BEGIN_SRC lisp
(declaim
 #-d2c-debug (inline table-value-ref)
 (ftype
  (function (keyword list &key (:default t) (:column (or keyword null))) t)
  table-value-ref))
(defun table-value-ref (table-designator predicates
                        &key (default nil) (column nil))
  "References the data table designated by TABLE-DESIGNATOR by plist
PREDICATES, returning either (1) the column value, if it is just a single
column, (2) a plist of columns if there are multiple, or (3) DEFAULT, if no
row corresponding to PREDICATES is found. COLUMN, if non-NIL, specifies the
column to return in (2) case. This function assumes that the column names in
PREDICATES are alphabetically sorted.

See TABLE-VALUE-REF*"
  (if-let (table (gethash table-designator *data-tables*))
    (if-let (row (gethash predicates table))
      (if column
          (getf row column)
          row)
      default)
    default))
#+END_SRC

The important detail of the contract for this function is that supplied ~predicates~ plist should be alphabetically sorted by the names of the columns, since this is how they're stored in the hashtables we've discussed above. If we change the order, the hash value of the list would change and this function wouldn't be able to find the requested row.

To alleviate that, there's a star version of this function, ~table-value-ref*~, that does the ~predicates~ list sorting at the cost of slight performance penalty:

#+NAME: table-value-ref*
#+BEGIN_SRC lisp
(declaim
 #-d2c-debug (inline table-value-ref*)
 (ftype (function (keyword list &key (:default t) (:column keyword)) t)
        table-value-ref*))
(defun table-value-ref* (table-designator predicates
                         &key (default nil) (column nil))
  "References the data table designated by TABLE-DESIGNATOR by plist
PREDICATES, returning either (1) the column value, if it is just a single
column, (2) a plist of columns if there are multiple, or (3) DEFAULT, if no
row corresponding to PREDICATES is found. COLUMN, if non-NIL, specifies the
column to return in (2) case. This function makes sure that the column names
in PREDICATES are alphabetically sorted and therefore works slightly slower.

See TABLE-VALUE-REF"
  (table-value-ref table-designator
                   (sort predicates
                         #'string<
                         :key #'car)
                   :default default
                   :column column))
#+END_SRC

** CastleDB format support

** ECS

** Events

** Actions

** Renderer

** Aseprite format support

** UI system

# Local Variables:
# org-src-preserve-indentation: t
# End:
