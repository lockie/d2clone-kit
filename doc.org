#+STARTUP: showall indent hidestars

* Quickstart

d2clone-kit engine requires [[https://liballeg.org][liballegro]] game programming library to function (*unrelated* to Allegro Common Lisp; d2clone-kit supports variety of Common Lisp compilers, including SBCL).

To install liballegro development files, refer to your distribution's package manager; for instance, on Debian derivatives (including Ubuntu and Mint) issue the following command:

#+BEGIN_SRC shell
sudo apt-get install liballegro-acodec5-dev liballegro-audio5-dev \
    liballegro-image5-dev liballegro-dialog5-dev liballegro-ttf5-dev \
    liballegro-physfs5-dev liballegro-video5-dev
#+END_SRC

Now, clone the repo to your [[https://quicklisp.org][Quicklisp]] directory and download resource files:

#+BEGIN_SRC shell
export QUICKLISP_DIR=~/quicklisp  # adjust according to your Quicklisp path
git clone https://gitlab.com/lockie/d2clone-kit $QUICKLISP_DIR/local-projects/d2clone-kit
wget https://gitlab.com/lockie/darkness-looming-the-dawn/-/raw/master/Resources/assets.zip \
    -P $QUICKLISP_DIR/local-projects/d2clone-kit/Resources/
cd $QUICKLISP_DIR/local-projects/d2clone-kit/src/
#+END_SRC

Start your favourite Lisp (or slime/sly) from engine's =src/= subdirectory.
To launch the built-in engine demo using the resources you've downloaded, type in REPL:

#+BEGIN_SRC lisp
(ql:register-local-projects)
(ql:quickload :d2clone-kit)
(d2clone-kit:demo)
#+END_SRC

* Source code walkthrough

d2clone-kit is licensed under the GNU GPL license version 3.

We put all of engine's source code into ~:d2clone-kit~ package.

#+NAME: preamble
#+BEGIN_SRC lisp
;;;; Copyright (C) 2020-2021 Andrew Kravchuk and contributors
;;;;
;;;; This program is free software: you can redistribute it and/or modify
;;;; it under the terms of the GNU General Public License as published by
;;;; the Free Software Foundation, either version 3 of the License, or
;;;; (at your option) any later version.
;;;;
;;;; This program is distributed in the hope that it will be useful,
;;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;;; GNU General Public License for more details.
;;;;
;;;; You should have received a copy of the GNU General Public License
;;;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;;;; WARNING: DO NOT EDIT, AUTO-GENERATED CODE. Edit doc.org instead.

(in-package :d2clone-kit)
#+END_SRC

** Entry point

#+BEGIN_SRC lisp :tangle d2clone-kit.lisp :noweb yes :exports none
<<preamble>>

<<game-loop>>

<<callback-globals>>

<<new-game>>

<<game-started-p>>

<<package-version>>

<<run-engine-1>>
<<run-engine-2>>
<<run-engine-3>>
<<run-engine-4>>
<<run-engine-5>>
<<run-engine-6>>
<<run-engine-7>>
<<run-engine-8>>
<<run-engine-9>>

<<start-engine>>

<<demo>>
#+END_SRC

The entry point to the game, should it be ~d2clone-kit:demo~ or other kind of ~main~ function supplied to ~:entry-point~ argument of game's ~asdf:defsystem~, just needs to call ~start-engine~ with appropriate arguments:

#+NAME: demo
#+BEGIN_SRC lisp
(defun demo ()
  "Runs built-in engine demo."
  (start-engine
   "demo"
   ;; TODO : load that from map file!
   ;; TODO : also store initial player position in the file
   ;;  (or some kind of "entrypoint" or "spawnpoint")
   '(((:camera)
      (:coordinate :x 0d0 :y 0d0))
     ((:player)
      (:coordinate :x 0d0 :y 0d0)
      (:sprite :prefab :heroine :layers-initially-toggled (:head :clothes))
      (:character)
      (:hp :current 100d0 :maximum 100d0)
      (:mana :current 100d0 :maximum 100d0)
      (:combat :min-damage 1d0 :max-damage 2d0))
     ((:mob :name "Spiderant")
      (:coordinate :x 2d0 :y 2d0)
      (:sprite :prefab :spiderant :layers-initially-toggled (:body))
      (:character :speed 1d0)
      (:hp :current 15d0 :maximum 15d0)
      (:combat :min-damage 1d0 :max-damage 10d0))
     ;; ((:mob :name "Spiderant")
     ;;  (:coordinate :x 4d0 :y 4d0)
     ;;  (:sprite :prefab :spiderant :layers-initially-toggled (:body))
     ;;  (:character :speed 1d0)
     ;;  (:hp :current 50d0 :maximum 50d0))
     ;; ((:mob :name "Spiderant")
     ;;  (:coordinate :x 3d0 :y 3d0)
     ;;  (:sprite :prefab :spiderant :layers-initially-toggled (:body))
     ;;  (:character :speed 1d0)
     ;;  (:hp :current 50d0 :maximum 50d0))
     ((:coordinate :x 0d0 :y 0d0)
      (:map :prefab :map)))
   nil))
#+END_SRC

** Engine

To start the engine, we'll save the arguments passed to ~start-engine~ to dynamic variables defined above to properly pass it to CFFI callback we'll discuss in a moment:

#+NAME: callback-globals
#+BEGIN_SRC lisp
(defvar *game-name*)
(defvar *sanitized-game-name*)
(defvar *new-game-object-specs*)
(defvar *config-options*)
(defvar *table-indices*)
#+END_SRC

Then we use ~float-features:with-float-traps-masked~ from Shinmera's [[https://shinmera.github.io/float-features][float-features]] library to stop Lisp popping up with floating point errors (like e.g. [[https://en.wikipedia.org/wiki/Arithmetic_underflow][underflow]]) which are usual (and by default ignored) in C world.

Finally, we call [[https://liballeg.org/a5docs/trunk/misc.html#al_run_main][al:run-main]] from liballegro with the ~run-engine~ [[https://common-lisp.net/project/cffi/manual/html_node/defcallback.html][CFFI callback]]; this is required in order for the game to be able to run under MacOS with its weird main thread rules.

#+NAME: start-engine
#+BEGIN_SRC lisp
(defunl start-engine (game-name new-game-object-specs table-indices
                                &rest config)
  "Initializes and starts engine to run the game named by GAME-NAME.
NEW-GAME-OBJECT-SPECS is list of game object specifications to be created when
 the new game is started with MAKE-OBJECT. TABLE-INDICES, if non-nil,
 specifies the columns in indices to build from a data tables read from .cdb
 file with BUILD-DATA-TABLES. CONFIG plist is used to override variables read
 from config file.

See MAKE-OBJECT
See BUILD-DATA-TABLES"
  (let ((*game-name* game-name)
        (*sanitized-game-name* (sanitize-filename game-name))
        (*new-game-object-specs* new-game-object-specs)
        (*config-options* config)
        (*table-indices* table-indices))
    (float-features:with-float-traps-masked
        (:divide-by-zero :invalid :inexact :overflow :underflow)
      (al:run-main 0 (cffi:null-pointer) (cffi:callback run-engine)))))
#+END_SRC

~run-engine~ begins with ~with-condition-reporter~ macro:

#+NAME: run-engine-1
#+BEGIN_SRC lisp
(cffi:defcallback run-engine :int ((argc :int) (argv :pointer))
  (declare (ignore argc argv))
  (with-condition-reporter
#+END_SRC

This macro executes a block of code, and if it triggers an unhandled condition, it displays nice GUI dialog with [[https://liballeg.org/a5docs/trunk/native_dialog.html#al_show_native_message_box][al:show-native-message-box]] displaying its description and good old "Hey guys" error message. Of course this only happens when you're not running your Lisp under debugger. Also, this macro puts condition description as well as full backtrace to liballegro log.

#+NAME: with-condition-reporter
#+BEGIN_SRC lisp
(defmacro with-condition-reporter (&body body)
  "Executes BODY with generic error handler which puts full error
condition info including backtrace to liballegro log and displays error
messagebox when not in debugger."
  `(handler-bind
       ((error #'(lambda (e)
                   (log-error "~a"
                              (with-output-to-string (s)
                                (uiop:print-condition-backtrace e :stream s)))
                   (unless *debugger-hook*
                     (al:show-native-message-box
                      (cffi:null-pointer) "Hey guys"
                      "We got a big error here :(" (format nil "~a" e)
                      (cffi:null-pointer) :error)))))
     ,@body))
#+END_SRC

So the next thing ~run-engine~ does is determining the data directory (something like =~/.local/share/demo/=, where =demo= is the name of the game sans forbidden characters, which is held in ~*sanitized-game-name*~ variable).

#+NAME: run-engine-2
#+BEGIN_SRC lisp
    (let ((data-dir
            (merge-pathnames
             (make-pathname :directory `(:relative ,*sanitized-game-name*))
             (uiop:xdg-data-home))))
      (ensure-directories-exist data-dir)
#+END_SRC

Next, we initialize core liballegro facilities: logging, the library itself, filesystem and configuration subsystems.

#+NAME: run-engine-3
#+BEGIN_SRC lisp
      ;; TODO : ability to set level e.g. by command line variable
      ;;  (it is not possible through config because of "deadlock")
      (init-log data-dir)
      (al:set-app-name *sanitized-game-name*)
      (al:init)
      (log-info "Starting d2clone-kit engine ~a"
                (package-version "v~a" :d2clone-kit))
      (init-fs *sanitized-game-name* data-dir)
      (init-config))

#+END_SRC

Right after logging is initialized, we emit a newborn cry - the very first log line, reporting engine version by using the following nice helper function which tries to get given package version from [[https://common-lisp.net/project/asdf/][ASDF]]:

#+NAME: package-version
#+BEGIN_SRC lisp
(declaim
 (ftype (function (string (or character symbol string)) (or string null))
        package-version))
(defun package-version (format package)
  "Returns the PACKAGE version from asdf formatted according to FORMAT. If the
package does not exist, then retuns NIL."
  (values
   (when-let (package-instance (asdf:find-system package nil))
     (format nil format (slot-value package-instance 'asdf:version)))))
#+END_SRC

Afterwards, we initialize various liballegro addons:

#+NAME: run-engine-4
#+BEGIN_SRC lisp
    ;; TODO : proper recover from those errors (properly finalize)+retry restart
    (unless (al:init-primitives-addon)
      (error "Initializing primitives addon failed"))
    (unless (al:init-image-addon)
      (error "Initializing image addon failed"))
    (al:init-font-addon)
    (unless (al:init-ttf-addon)
      (error "Initializing TTF addon failed"))
    (unless (al:install-audio)
      (error "Intializing audio addon failed"))
    (unless (al:init-acodec-addon)
      (error "Initializing audio codec addon failed"))
    (unless (al:restore-default-mixer)
      (error "Initializing default audio mixer failed"))

#+END_SRC

Then we set the configuration variables that might've been set in call to ~start-engine~:

#+NAME: run-engine-5
#+BEGIN_SRC lisp
    (doplist (key val *config-options*)
      (apply #'(setf config) val
             (mapcar #'make-keyword
                     (uiop:split-string (string key) :separator '(#\-)))))

#+END_SRC

Next, we setup various display parameters, such as width and height of the viewport and multisampling.

#+NAME: run-engine-6
#+BEGIN_SRC lisp
    (with-system-config-options
        ((display-windowed display-multisampling display-width display-height))
      (al:set-new-display-flags
       ;; TODO : fix fullscreen
       (if display-windowed
           '(:windowed)
           '(:fullscreen-window :frameless)))
      (unless (zerop display-multisampling)
        (al:set-new-display-option :sample-buffers 1 :require)
        (al:set-new-display-option :samples display-multisampling :require))

#+END_SRC

After that, we create the display and initialize various liballegro event sources, so that we can process the events in our game loop:

#+NAME: run-engine-7
#+BEGIN_SRC lisp
      (let ((display (al:create-display display-width display-height))
            (event-queue (al:create-event-queue)))
        (when (cffi:null-pointer-p display)
          (error "Initializing display failed"))
        (al:inhibit-screensaver t)
        (al:set-window-title display *game-name*)
        (al:register-event-source event-queue
                                  (al:get-display-event-source display))
        (al:install-keyboard)
        (al:register-event-source event-queue (al:get-keyboard-event-source))
        (al:install-mouse)
        (al:register-event-source event-queue (al:get-mouse-event-source))
        (setf *event-source* (cffi:foreign-alloc '(:struct al::event-source)))
        (al:init-user-event-source *event-source*)
        (al:register-event-source event-queue *event-source*)

#+END_SRC

A few more tweaks, related to the accelerated bitmaps in video memory and random number generator:

#+NAME: run-engine-8
#+BEGIN_SRC lisp
        (al:set-new-bitmap-flags '(:video-bitmap))

        (setf *random-state* (make-random-state t))

#+END_SRC

And finally, we can prepare and start the game loop.

First, we initialize the data tables containing various game-specific values from the =*.cdb= resource files they're stored in by the call to ~load-data-tables~. Next, we initialize the ECS subsystem of the engine with a call to ~initialize-systems~, and then call ~game-loop~ function within the confines of ~unwind-protect~ which handles proper finalization of the engine:

#+NAME: run-engine-9
#+BEGIN_SRC lisp
        (unwind-protect
             (progn
               (load-data-tables *table-indices*)
               (initialize-systems)
               (game-loop event-queue))
          (log-info "Shutting engine down")
          (when (entity-valid-p *session-entity*)
            (delete-entity *session-entity*))
          (setf *session-entity* +invalid-entity+)
          (finalize-systems)
          (finalize-entities)
          (finalize-actions)
          (growable-vector-clear *event-queue*)
          (al:inhibit-screensaver nil)
          (al:destroy-user-event-source *event-source*)
          (cffi:foreign-free *event-source*)
          (setf *event-source* (cffi:null-pointer))
          (al:destroy-event-queue event-queue)
          (al:destroy-display display)
          (al:stop-samples)
          (close-config)
          (al:uninstall-system)
          (al:uninstall-audio)
          (al:shutdown-ttf-addon)
          (al:shutdown-font-addon)
          (al:shutdown-image-addon)
          (al:shutdown-primitives-addon)
          (close-fs)))))
  0)
#+END_SRC

*** Game loop

TODO

#+NAME: game-loop
#+BEGIN_SRC lisp
(declaim
 #-d2c-debug (inline ui-handle-event)
 (ftype (function (cffi:foreign-pointer) boolean) ui-handle-event))
(defun ui-handle-event (event)
  (and (ui-on-p)
       (positive-fixnum-p (the fixnum (nk:allegro-handle-event event)))))

(declaim
 #-d2c-debug (inline systems-handle-event)
 (ftype (function (cffi:foreign-pointer) boolean) systems-handle-event))
(defun systems-handle-event (event)
  (let* ((type (cffi:foreign-slot-value event '(:union al:event) 'al::type))
         (allegro-event (make-allegro-event :type type :struct event)))
    ;; NOTE : processing allegro event without queueing, because event struct
    ;; is stack allocated
    (with-systems system
      (process-event system allegro-event))
    (not (eq type :display-close))))

(declaim
 (ftype
  (function (cffi:foreign-pointer &key (:repl-update-interval double-float)))
  game-loop))
(defunl game-loop (event-queue &key (repl-update-interval 0.3d0))
  "Runs game loop."
  (gc :full t)
  (log-info "Starting game loop")
  (livesupport:setup-lisp-repl)
  (uiop:nest
   (with-system-config-options ((display-vsync display-fps)))
   (let* ((vsync display-vsync)
          (renderer (make-renderer))
          (last-tick (the double-float (al:get-time)))
          (last-repl-update last-tick)))
   (cffi:with-foreign-object (event '(:union al:event))
     (sleep 0.016)
     (loop
       :do (restart-case
               (progn
                 (nk:with-input (ui-context)
                   (unless (loop :while (al:get-next-event event-queue event)
                                 :always (or (ui-handle-event event)
                                             (systems-handle-event event)))
                     (loop-finish)))
                 (process-events)
                 (let ((current-tick (the double-float (al:get-time))))
                   (when (> (- current-tick last-repl-update)
                            repl-update-interval)
                     (livesupport:update-repl-link)
                     (setf last-repl-update current-tick))
                   (setf *delta-time* (- current-tick last-tick))
                   ;; TODO : draw FPS counter above the UI
                   (when display-fps
                     ;; TODO : smooth FPS counter, like in allegro examples
                     (add-debug-text :fps "FPS: ~d" (round 1 *delta-time*)))
                   (process-actions)
                   ;; TODO : use separate threads for updating?..
                   (with-systems sys
                     ;; TODO : replace system-update with event?.. maybe even
                     ;; system-draw too?..
                     (system-update sys))
                   (with-systems sys
                     (system-draw sys renderer))
                   (al:clear-to-color (al:map-rgb 0 0 0))
                   (do-draw renderer)
                   (setf last-tick current-tick))
                 (when vsync
                   (setf vsync (al:wait-for-vsync)))
                 (nk:allegro-render)
                 (al:flip-display))
             ;; TODO restart to terminate the loop
             (next-iteration ()
               :report "Proceed to next game loop iteration."
               nil))))))
#+END_SRC

*** Game session

There are a couple more functions defined in =d2clone-kit.lisp= file, and they both are related to the game session and both called only from GUI scripts.

First one, ~new-game~ initializes a new game by recreating ~*session-entity*~, which is the parent of all entities created in the game session (we'll delve into entities in a few). It also clears the event queue.

#+NAME: new-game
#+BEGIN_SRC lisp
(defun new-game ()
  "Starts new game."
  (log-info "Starting new game")
  (when (entity-valid-p *session-entity*)
    (delete-entity *session-entity*))
  (growable-vector-clear *event-queue*)
  (setf (player-system-last-target *player-system*) +invalid-entity+)
  (setf *session-entity* (make-entity))
  (dolist (spec *new-game-object-specs*)
    (make-object spec *session-entity*)))
#+END_SRC

The second one, ~game-started-p~ returns boolean indicating whether there currently is an active gameplay session.

#+NAME: game-started-p
#+BEGIN_SRC lisp
(declaim
 #-d2c-debug (inline game-started-p)
 (ftype (function () boolean) game-started-p))
(defun game-started-p ()
  "Returns boolean indicating whether the game session is currently running."
  ;; HACK
  (entity-valid-p (player-system-entity *player-system*)))
#+END_SRC

** Logging

#+BEGIN_SRC lisp :tangle log.lisp :noweb yes :exports none
<<preamble>>

<<defunl>>

<<with-condition-reporter>>
#+END_SRC

~defunl~ is the simple macro wrapper over standard ~defun~, which puts the function name to the dynamic variable ~*function-name*~.

#+NAME: defunl
#+BEGIN_SRC lisp
(defvar *function-name* "")

(defmacro defunl (fname lambda-list &body body)
  "DEFUN wrapper which sets correct current function name for logging
functions."
  (let ((docstring (when (stringp (car body)) (pop body))))
    `(defun ,fname ,lambda-list
       ,@(ensure-list docstring)
       (let ((*function-name* (quote ,fname)))
         ,@body))))
#+END_SRC

This variable is being used to supply the function name to liballegro logging subsytem, so that the names of Lisp functions can nicely appear in logs, like that:

#+BEGIN_EXAMPLE
system      I al_install_system [   0.00000] Allegro version: 5.2.7
d2clone-kit I start-engine      [   0.00027] Starting d2clone-kit engine v0.1.2
d2clone-kit I init-fs           [   0.00031] Appending /home/andrew/Progs/GAMEDEV/d2clone-kit/Resources to mount points
#+END_EXAMPLE


# Local Variables:
# org-src-preserve-indentation: t
# End:
