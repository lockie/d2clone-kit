#+STARTUP: showall indent hidestars

* Quickstart

d2clone-kit engine requires [[https://liballeg.org][liballegro]] game programming library to function (*unrelated* to Allegro Common Lisp; d2clone-kit supports variety of Common Lisp compilers, including SBCL).

To install liballegro development files, refer to your distribution's package manager; for instance, on Debian derivatives (including Ubuntu and Mint) issue the following command:

#+BEGIN_SRC shell
sudo apt-get install liballegro-acodec5-dev liballegro-audio5-dev \
    liballegro-image5-dev liballegro-dialog5-dev liballegro-ttf5-dev \
    liballegro-physfs5-dev liballegro-video5-dev
#+END_SRC

Now, clone the repo to your [[https://quicklisp.org][Quicklisp]] directory and download resource files (note that you don't have to unpack the resources archive, d2clone-kit features reading files from zip archives):

#+BEGIN_SRC shell
export QUICKLISP_DIR=~/quicklisp  # adjust according to your Quicklisp path
git clone https://gitlab.com/lockie/d2clone-kit $QUICKLISP_DIR/local-projects/d2clone-kit
wget https://gitlab.com/lockie/darkness-looming-the-dawn/-/raw/master/Resources/assets.zip \
    -P $QUICKLISP_DIR/local-projects/d2clone-kit/Resources/
cd $QUICKLISP_DIR/local-projects/d2clone-kit/src/
#+END_SRC


Start your favourite Lisp (or slime/sly) from engine's =src/= subdirectory.
To launch the built-in engine demo using the resources you've downloaded, type in REPL:

#+BEGIN_SRC lisp
(ql:register-local-projects)
(ql:quickload :d2clone-kit)
(d2clone-kit:demo)
#+END_SRC

* Source code walkthrough

d2clone-kit is licensed under the GNU GPL license version 3.

We put all of engine's source code into ~:d2clone-kit~ package.

#+NAME: preamble
#+BEGIN_SRC lisp
;;;; Copyright (C) 2020-2021 Andrew Kravchuk and contributors
;;;;
;;;; This program is free software: you can redistribute it and/or modify
;;;; it under the terms of the GNU General Public License as published by
;;;; the Free Software Foundation, either version 3 of the License, or
;;;; (at your option) any later version.
;;;;
;;;; This program is distributed in the hope that it will be useful,
;;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;;; GNU General Public License for more details.
;;;;
;;;; You should have received a copy of the GNU General Public License
;;;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;;;; WARNING: DO NOT EDIT, AUTO-GENERATED CODE. Edit doc.org instead.

(in-package :d2clone-kit)
#+END_SRC

** Entry point

#+BEGIN_SRC lisp :tangle d2clone-kit.lisp :noweb yes :exports none
<<preamble>>

<<ui-handle-event>>

<<systems-handle-event>>

<<game-loop-1>>
<<game-loop-2>>
<<game-loop-3>>
<<game-loop-4>>
<<game-loop-5>>
<<game-loop-6>>
<<game-loop-7>>

<<callback-globals>>

<<new-game>>

<<game-started-p>>

<<package-version>>

<<run-engine-1>>
<<run-engine-2>>
<<run-engine-3>>
<<run-engine-4>>
<<run-engine-5>>
<<run-engine-6>>
<<run-engine-7>>
<<run-engine-8>>
<<run-engine-9>>

<<start-engine>>

<<demo>>
#+END_SRC

The entry point to the game, should it be ~d2clone-kit:demo~ or other kind of ~main~ function supplied to ~:entry-point~ argument of game's ~asdf:defsystem~, just needs to call ~start-engine~ with appropriate arguments:

#+NAME: demo
#+BEGIN_SRC lisp
(defun demo ()
  "Runs built-in engine demo."
  (start-engine
   "demo"
   ;; TODO : load that from map file!
   ;; TODO : also store initial player position in the file
   ;;  (or some kind of "entrypoint" or "spawnpoint")
   '(((:camera)
      (:coordinate :x 0d0 :y 0d0))
     ((:player)
      (:coordinate :x 0d0 :y 0d0)
      (:sprite :prefab :heroine :layers-initially-toggled (:head :clothes))
      (:character)
      (:hp :current 100d0 :maximum 100d0)
      (:mana :current 100d0 :maximum 100d0)
      (:combat :min-damage 1d0 :max-damage 2d0))
     ((:mob :name "Spiderant")
      (:coordinate :x 2d0 :y 2d0)
      (:sprite :prefab :spiderant :layers-initially-toggled (:body))
      (:character :speed 1d0)
      (:hp :current 15d0 :maximum 15d0)
      (:combat :min-damage 1d0 :max-damage 10d0))
     ;; ((:mob :name "Spiderant")
     ;;  (:coordinate :x 4d0 :y 4d0)
     ;;  (:sprite :prefab :spiderant :layers-initially-toggled (:body))
     ;;  (:character :speed 1d0)
     ;;  (:hp :current 50d0 :maximum 50d0))
     ;; ((:mob :name "Spiderant")
     ;;  (:coordinate :x 3d0 :y 3d0)
     ;;  (:sprite :prefab :spiderant :layers-initially-toggled (:body))
     ;;  (:character :speed 1d0)
     ;;  (:hp :current 50d0 :maximum 50d0))
     ((:coordinate :x 0d0 :y 0d0)
      (:map :prefab :map)))
   nil))
#+END_SRC

** Engine

To start the engine, we'll save the arguments passed to ~start-engine~ to dynamic variables defined below to properly pass it to CFFI callback we'll discuss in a moment:

#+NAME: callback-globals
#+BEGIN_SRC lisp
(defvar *game-name*)
(defvar *sanitized-game-name*)
(defvar *new-game-object-specs*)
(defvar *config-options*)
(defvar *table-indices*)
#+END_SRC

Then we use ~float-features:with-float-traps-masked~ from Shinmera's [[https://shinmera.github.io/float-features][float-features]] library to stop Lisp popping up with floating point errors (like e.g. [[https://en.wikipedia.org/wiki/Arithmetic_underflow][underflow]]) which are usual (and by default ignored) in C world.

Finally, we call [[https://liballeg.org/a5docs/trunk/misc.html#al_run_main][~al:run-main~]] from liballegro with the ~run-engine~ [[https://common-lisp.net/project/cffi/manual/html_node/defcallback.html][CFFI callback]]; this is required in order for the game to be able to run under MacOS with its weird main thread rules.

#+NAME: start-engine
#+BEGIN_SRC lisp
(defunl start-engine (game-name new-game-object-specs table-indices
                                &rest config)
  "Initializes and starts engine to run the game named by GAME-NAME.
NEW-GAME-OBJECT-SPECS is list of game object specifications to be created when
 the new game is started with MAKE-OBJECT. TABLE-INDICES, if non-nil,
 specifies the columns in indices to build from a data tables read from .cdb
 file with BUILD-DATA-TABLES. CONFIG plist is used to override variables read
 from config file.

See MAKE-OBJECT
See BUILD-DATA-TABLES"
  (let ((*game-name* game-name)
        (*sanitized-game-name* (sanitize-filename game-name))
        (*new-game-object-specs* new-game-object-specs)
        (*config-options* config)
        (*table-indices* table-indices))
    (float-features:with-float-traps-masked
        (:divide-by-zero :invalid :inexact :overflow :underflow)
      (al:run-main 0 (cffi:null-pointer) (cffi:callback run-engine)))))
#+END_SRC

~run-engine~ begins with ~with-condition-reporter~ macro:

#+NAME: run-engine-1
#+BEGIN_SRC lisp
(cffi:defcallback run-engine :int ((argc :int) (argv :pointer))
  (declare (ignore argc argv))
  (with-condition-reporter
#+END_SRC

This macro executes a block of code, and if it triggers an unhandled condition, it displays nice GUI dialog with [[https://liballeg.org/a5docs/trunk/native_dialog.html#al_show_native_message_box][~al:show-native-message-box~]] displaying its description and good old "Hey guys" error message. Of course this only happens when you're not running your Lisp under debugger (e.g. slime/sly). Also, this macro puts condition description as well as full backtrace to liballegro log.

#+NAME: with-condition-reporter
#+BEGIN_SRC lisp
(defmacro with-condition-reporter (&body body)
  "Executes BODY with generic error handler which puts full error
condition info including backtrace to liballegro log and displays error
messagebox when not in debugger."
  `(handler-bind
       ((error #'(lambda (e)
                   (log-error "~a"
                              (with-output-to-string (s)
                                (uiop:print-condition-backtrace e :stream s)))
                   (unless *debugger-hook*
                     (al:show-native-message-box
                      (cffi:null-pointer) "Hey guys"
                      "We got a big error here :(" (format nil "~a" e)
                      (cffi:null-pointer) :error)))))
     ,@body))
#+END_SRC

So the next thing ~run-engine~ does is determining the *data directory* (something like =~/.local/share/demo/=, where =demo= is the name of the game sans forbidden characters, which is held in ~*sanitized-game-name*~ variable).

#+NAME: run-engine-2
#+BEGIN_SRC lisp
    (let ((data-dir
            (merge-pathnames
             (make-pathname :directory `(:relative ,*sanitized-game-name*))
             (uiop:xdg-data-home))))
      (ensure-directories-exist data-dir)
#+END_SRC

Next, we initialize core liballegro facilities: logging, the library itself, filesystem and configuration subsystems.

#+NAME: run-engine-3
#+BEGIN_SRC lisp
      ;; TODO : ability to set level e.g. by command line variable
      ;;  (it is not possible through config because of "deadlock")
      (init-log data-dir)
      (al:set-app-name *sanitized-game-name*)
      (al:init)
      (log-info "Starting d2clone-kit engine ~a"
                (package-version "v~a" :d2clone-kit))
      (init-fs *sanitized-game-name* data-dir)
      (init-config))

#+END_SRC

Right after logging is initialized, we emit a newborn cry - the very first log line, reporting engine version by using the following nice helper function which tries to get given package version from [[https://common-lisp.net/project/asdf/][ASDF]]:

#+NAME: package-version
#+BEGIN_SRC lisp
(declaim
 (ftype (function (string (or character symbol string)) (or string null))
        package-version))
(defun package-version (format package)
  "Returns the PACKAGE version from asdf formatted according to FORMAT. If the
package does not exist, then retuns NIL."
  (values
   (when-let (package-instance (asdf:find-system package nil))
     (format nil format (slot-value package-instance 'asdf:version)))))
#+END_SRC

Afterwards, we initialize various [[https://liballeg.org/a5docs/trunk/index.html#addons][liballegro addons]]:

#+NAME: run-engine-4
#+BEGIN_SRC lisp
    ;; TODO : proper recover from those errors (properly finalize)+retry restart
    (unless (al:init-primitives-addon)
      (error "Initializing primitives addon failed"))
    (unless (al:init-image-addon)
      (error "Initializing image addon failed"))
    (al:init-font-addon)
    (unless (al:init-ttf-addon)
      (error "Initializing TTF addon failed"))
    (unless (al:install-audio)
      (error "Intializing audio addon failed"))
    (unless (al:init-acodec-addon)
      (error "Initializing audio codec addon failed"))
    (unless (al:restore-default-mixer)
      (error "Initializing default audio mixer failed"))

#+END_SRC

Then we set the configuration variables that might've been set in call to ~start-engine~:

#+NAME: run-engine-5
#+BEGIN_SRC lisp
    (doplist (key val *config-options*)
      (apply #'(setf config) val
             (mapcar #'make-keyword
                     (uiop:split-string (string key) :separator '(#\-)))))

#+END_SRC

Next, we setup various display parameters, such as width and height of the viewport and multisampling.

#+NAME: run-engine-6
#+BEGIN_SRC lisp
    (with-system-config-options
        ((display-windowed display-multisampling display-width display-height))
      (al:set-new-display-flags
       ;; TODO : fix fullscreen
       (if display-windowed
           '(:windowed)
           '(:fullscreen-window :frameless)))
      (unless (zerop display-multisampling)
        (al:set-new-display-option :sample-buffers 1 :require)
        (al:set-new-display-option :samples display-multisampling :require))

#+END_SRC

After that, we create the display and initialize various liballegro event sources, so that we can process the events in our game loop:

#+NAME: run-engine-7
#+BEGIN_SRC lisp
      (let ((display (al:create-display display-width display-height))
            (event-queue (al:create-event-queue)))
        (when (cffi:null-pointer-p display)
          (error "Initializing display failed"))
        (al:inhibit-screensaver t)
        (al:set-window-title display *game-name*)
        (al:register-event-source event-queue
                                  (al:get-display-event-source display))
        (al:install-keyboard)
        (al:register-event-source event-queue (al:get-keyboard-event-source))
        (al:install-mouse)
        (al:register-event-source event-queue (al:get-mouse-event-source))
        (setf *event-source* (cffi:foreign-alloc '(:struct al::event-source)))
        (al:init-user-event-source *event-source*)
        (al:register-event-source event-queue *event-source*)

#+END_SRC

A few more tweaks, related to the accelerated bitmaps in video memory and random number generator:

#+NAME: run-engine-8
#+BEGIN_SRC lisp
        (al:set-new-bitmap-flags '(:video-bitmap))

        (setf *random-state* (make-random-state t))

#+END_SRC

And finally, we can prepare and start the game loop by calling ~game-loop~ function.

First, we initialize the data tables containing various game-specific values from the =*.cdb= resource files they're stored in by the call to ~load-data-tables~. We'll cover this in detail in [[Data tables]] section. Next, we initialize the ECS subsystem of the engine with a call to ~initialize-systems~, and then call ~game-loop~ function within the confines of ~unwind-protect~ which handles proper finalization of the engine:

#+NAME: run-engine-9
#+BEGIN_SRC lisp
        (unwind-protect
             (progn
               (load-data-tables *table-indices*)
               (initialize-systems)
               (game-loop event-queue))
          (log-info "Shutting engine down")
          (when (entity-valid-p *session-entity*)
            (delete-entity *session-entity*))
          (setf *session-entity* +invalid-entity+)
          (finalize-systems)
          (finalize-entities)
          (finalize-actions)
          (growable-vector-clear *event-queue*)
          (al:inhibit-screensaver nil)
          (al:destroy-user-event-source *event-source*)
          (cffi:foreign-free *event-source*)
          (setf *event-source* (cffi:null-pointer))
          (al:destroy-event-queue event-queue)
          (al:destroy-display display)
          (al:stop-samples)
          (close-config)
          (al:uninstall-system)
          (al:uninstall-audio)
          (al:shutdown-ttf-addon)
          (al:shutdown-font-addon)
          (al:shutdown-image-addon)
          (al:shutdown-primitives-addon)
          (close-fs)))))
  0)
#+END_SRC

*** Game loop

The game loop starts with calling garbage collector using the ~gc~ function from the [[https://common-lisp.net/project/trivial-garbage/][trivial-garbage]] library. After that, leaving some comment in log, we setup the [[https://github.com/cbaggers/livesupport][livesupport]] library by calling ~setup-lisp-repl~. This amazing library allows to feed arbitrary code into REPL while the game is running. Next, by using ~uiop:next~ macro to avoid extra nesting, we prepare some variables for the loop. We read the ~display-vsync~ and ~display-fps~ variables from config (see the [[Config]] section for the discussion of ~with-system-config-options~ macro used for that). We also create a functional renderer instance with a call to ~make-renderer~ (discussed in [[Renderer]] section) and initialize some time counters using the [[https://liballeg.org/a5docs/trunk/time.html#al_get_time][~al:get-time~]] function, namely the timestamp of the last frame, called ~last-tick~ and last livesupport update time called ~last-repl-update~; we update livesupport REPL link once in 0.3 seconds by default, which is set in ~repl-update-interval~ keyword argument to the ~game-loop~ function.

#+NAME: game-loop-1
#+BEGIN_SRC lisp
(declaim
 (ftype
  (function (cffi:foreign-pointer &key (:repl-update-interval double-float)))
  game-loop))
(defunl game-loop (event-queue &key (repl-update-interval 0.3d0))
  "Runs game loop."
  (gc :full t)
  (log-info "Starting game loop")
  (livesupport:setup-lisp-repl)
  (uiop:nest
   (with-system-config-options ((display-vsync display-fps)))
   (let* ((vsync display-vsync)
          (renderer (make-renderer))
          (last-tick (the double-float (al:get-time)))
          (last-repl-update last-tick)))
#+END_SRC

Next, we allocate [[https://liballeg.org/a5docs/trunk/events.html#allegro_event][liballegro event]] foreign structure with ~cffi:with-foreign-object~ macro and sleep for approximately 1/60 of a second so that the calculated FPS value for the very first frame does not cause division by zero. After that, we finally start the actual game loop with its body wrapped into ~restart-case~ for some nice restarts we'll discuss in a few moments.

#+NAME: game-loop-2
#+BEGIN_SRC lisp
   (cffi:with-foreign-object (event '(:union al:event))
     (sleep 0.016)
     (loop
       :do (restart-case
               (progn
#+END_SRC

First of all, in the beginning of every frame, we process the events. We first try to feed the allegro events we receive with [[https://liballeg.org/a5docs/trunk/events.html#al_get_next_event][~al:get-next-event~]] to the [[https://github.com/Immediate-Mode-UI/Nuklear/][Nuklear]] library using ~ui-handle-event~ helper in case some UI windows are active. In case the event is not handled by Nuklear, we call ~systems-handle-event~ helper we'll discuss in a moment. Also note that we can receive several events per frame, so we also use ~loop~ construct here.

#+NAME: game-loop-3
#+BEGIN_SRC lisp
                 (nk:with-input (ui-context)
                   (unless (loop :while (al:get-next-event event-queue event)
                                 :always (or (ui-handle-event event)
                                             (systems-handle-event event)))
                     (loop-finish)))
#+END_SRC

~ui-handle-event~ helper basically just feeds the event to the ~nk:allegro-handle-event~ function from [[https://gitlab.com/lockie/cl-liballegro-nuklear][cl-liballegro-nuklear]] wrapper library. The minor optimization here is that we don't do that if there are no active UI windows, which we determine by the call to ~ui-on-p~ function described in [[UI system]] section.

#+NAME: ui-handle-event
#+BEGIN_SRC lisp
(declaim
 #-d2c-debug (inline ui-handle-event)
 (ftype (function (cffi:foreign-pointer) boolean) ui-handle-event))
(defun ui-handle-event (event)
  (and (ui-on-p)
       (positive-fixnum-p (the fixnum (nk:allegro-handle-event event)))))
#+END_SRC

~systems-hande-event~ helper serves as a bridge between the low-level liballegro events and high-level in-game events described in detail in [[Events]] section. It calls ~make-allegro-event~ constructor function to make an instance of in-game event and then feeds that instance to all ECS systems; we'll talk more about what ECS is in [[ECS][corresponding section]]. Note that ~systems-handle-event~ returns ~nil~ only when the type of event is ~:display-close~, which is produced by liballegro when the game window is closed. This fact is used in the game loop to finish it.

#+NAME: systems-handle-event
#+BEGIN_SRC lisp
(declaim
 #-d2c-debug (inline systems-handle-event)
 (ftype (function (cffi:foreign-pointer) boolean) systems-handle-event))
(defun systems-handle-event (event)
  (let* ((type (cffi:foreign-slot-value event '(:union al:event) 'al::type))
         (allegro-event (make-allegro-event :type type :struct event)))
    ;; NOTE : processing allegro event without queueing, because event struct
    ;; is stack allocated
    (with-systems system
      (process-event system allegro-event))
    (not (eq type :display-close))))
#+END_src

In game loop, after processing all low-level liballegro events, we separately process high-level events with ~process-events~ function, since the low-level event might trigger one or more high-level events and we don't want to deal with ordering issues.

After all of the events are processed, we do some time-based calculations. We get current frame's timestamp into the ~current-tick~ variable, check if we need to update livesupport REPL link with ~livesupport:update-repl-link~, calculate delta time between current frame and the previous one into the ~*delta-time*~ global variable and display FPS value if this is set in config.

#+NAME: game-loop-4
#+BEGIN_SRC lisp
                 (process-events)
                 (let ((current-tick (the double-float (al:get-time))))
                   (when (> (- current-tick last-repl-update)
                            repl-update-interval)
                     (livesupport:update-repl-link)
                     (setf last-repl-update current-tick))
                   (setf *delta-time* (- current-tick last-tick))
                   ;; TODO : draw FPS counter above the UI
                   (when display-fps
                     ;; TODO : smooth FPS counter, like in allegro examples
                     (add-debug-text :fps "FPS: ~d" (round 1 *delta-time*)))
#+END_SRC

Next, we call ~process-actions~ function which processes the actions related to every ECS system. Actions constitute separate framework used for multi-frame stateful actions performed by in-game entities; we'll cover those in detail in [[Actions][corresponding section]].

After that, we call ~system-update~ generic method in loop for every ECS system, which updates the aspects of the state of in-game entities being handled by those systems.

Further down the line, we call ~system-draw~ generic method which arranges the drawing commands needed for those state aspects to be drawn on screen with the ~renderer~ instance.

#+NAME: game-loop-5
#+BEGIN_SRC lisp
                   (process-actions)
                   ;; TODO : use separate threads for updating?..
                   (with-systems sys
                     ;; TODO : replace system-update with event?.. maybe even
                     ;; system-draw too?..
                     (system-update sys))
                   (with-systems sys
                     (system-draw sys renderer))
#+END_SRC

After those issues are handled, we proceed to actual drawing. We call [[https://liballeg.org/a5docs/trunk/graphics.html#al_clear_to_color][~al:clear-to-color~]] to flush the screen with the same black color, and then we call ~do-draw~ function which makes the functional renderer instance to do the actual draw calls. After swapping ~last-tick~ with ~current-tick~, we also call [[https://liballeg.org/a5docs/trunk/display.html#al_wait_for_vsync][~al:wait-for-vsync~]] if the vertical sync was set in config, and we call ~nk:allegro-render~ to render UI windows, if any. With that, we're finished with the draw calls, and we finally call [[https://liballeg.org/a5docs/trunk/display.html#al_flip_display][~al:flip-display~]] to swap drawing buffers.

#+NAME: game-loop-6
#+BEGIN_SRC lisp
                   (al:clear-to-color (al:map-rgb 0 0 0))
                   (do-draw renderer)
                   (setf last-tick current-tick))
                 (when vsync
                   (setf vsync (al:wait-for-vsync)))
                 (nk:allegro-render)
                 (al:flip-display))
#+END_SRC

At the bottom of the game loop body, we have a ~next-iteration~ restart, which allows to continue to the next iteration of loop when some condition arises within.

#+NAME: game-loop-7
#+BEGIN_SRC lisp
             ;; TODO restart to terminate the loop
             (next-iteration ()
               :report "Proceed to next game loop iteration."
               nil))))))
#+END_SRC

*** Game session

There are a couple more functions defined in =d2clone-kit.lisp= file, and they both are related to the game session and both called only from GUI scripts.

First one, ~new-game~ initializes a new game by recreating ~*session-entity*~, which is the parent of all entities created in the game session (we'll delve into entities in a few). It also clears the event queue.

#+NAME: new-game
#+BEGIN_SRC lisp
(defun new-game ()
  "Starts new game."
  (log-info "Starting new game")
  (when (entity-valid-p *session-entity*)
    (delete-entity *session-entity*))
  (growable-vector-clear *event-queue*)
  (setf (player-system-last-target *player-system*) +invalid-entity+)
  (setf *session-entity* (make-entity))
  (dolist (spec *new-game-object-specs*)
    (make-object spec *session-entity*)))
#+END_SRC

The second one, ~game-started-p~ returns boolean indicating whether there currently is an active gameplay session.

#+NAME: game-started-p
#+BEGIN_SRC lisp
(declaim
 #-d2c-debug (inline game-started-p)
 (ftype (function () boolean) game-started-p))
(defun game-started-p ()
  "Returns boolean indicating whether the game session is currently running."
  ;; HACK
  (entity-valid-p (player-system-entity *player-system*)))
#+END_SRC

** Logging

#+BEGIN_SRC lisp :tangle log.lisp :noweb yes :exports none
<<preamble>>

<<init-log>>

<<cfuns>>

<<defunl>>

<<last-message>>

<<trace-1>>
<<trace-2>>

<<deflog>>

<<with-condition-reporter>>
#+END_SRC

~init-log~ function first constructs the name of the log file, which would be =log.txt= residing in data directory. After that, it actually passes this file name to liballegro by setting the =ALLEGRO_TRACE= environment variable. Next, it tweaks a few logging parameters of liballegro. Namely, it (1) turns off the display of source code lines of log messages, because we can't reliably and easily get those in CL, and (2) it sets the log severity level, which by default is =info= and is being set in ~level~ optional argument to ~init-log~.

#+NAME: init-log
#+BEGIN_SRC lisp
(defun init-log (data-dir &optional (level "info"))
  (let ((log-file
          (merge-pathnames
           (make-pathname :name "log" :type "txt")
           data-dir)))
    ;; TODO : wait for liballegro 5.2.8 to release and then call
    ;;  al_register_trace_handler to handle output to both stdout & logfile
    (setf (uiop:getenv "ALLEGRO_TRACE")
          (namestring log-file)))
  (al:set-config-value (al:get-system-config) "trace" "lines" "0")
  (al:set-config-value (al:get-system-config) "trace" "level" level))
#+END_SRC

~%trace~ function is pivotal in the logging subsystem. It puts the messages with given severity level from Lisp side into liballegro log. To do that, it uses a couple of internal liballegro functions which are not a part of public interface. Therefore, we have to import those functions using CFFI:

#+NAME: cfuns
#+BEGIN_SRC lisp
(cffi:defcfun ("_al_trace_prefix" trace-prefix) :boolean
  (channel :string) (level :int) (file :string) (line :int) (function :string))

(cffi:defcfun ("_al_trace_suffix" trace-suffix) :void
  (msg :string) &rest)
#+END_SRC

The heavy lifting of logging is done by the ~do-trace~ local function, which first calls ~trace-prefix~ internal function we've imported, and if it succeeds, it calls ~trace-suffix~ further down; this is part of calling protocol of those functions. We add extra newline to the log message to be output, and after that we split it by 1024 byte portions, since this is the size of internal liballegro buffer, and if we don't do the splitting, the message will get truncated.

#+NAME: trace-1
#+BEGIN_SRC lisp
(defun %trace (level message args)
  (flet
      ((do-trace (level function-name message)
         (when (trace-prefix "d2clone-kit" level "" 0 function-name)
           (loop :with finalized-message := (format nil "~a~%" message)
                 :with length := (length finalized-message)
                 :for i :of-type fixnum :from 0 :to length :by 1024
                 :do (trace-suffix
                      "%s"
                      :string
                      (subseq finalized-message i (min length (+ i 1024))))))))
#+END_SRC

The ~%trace~ function first formats the arguments it has been given using the standard CL ~format~ function.

~%trace~ also features duplicate message detection which could be found in some popular logging utilities. It does that using the ~*last-message*~ and ~*last-message-repetitions*~ global variables defined above:

#+NAME: last-message
#+BEGIN_SRC lisp
(declaim (string *last-message*)
         (fixnum *last-message-repetitions*))
(global-vars:define-global-var *last-message* "")
(global-vars:define-global-var *last-message-repetitions* 0)
#+END_SRC

If the previous message was repeated more than once, before putting another message we add the line saying that /last message repeated/ that count of /times/.

After that, we finally put the actual log message along with the function name using ~do-trace~.

#+NAME: trace-2
#+BEGIN_SRC lisp
    (let ((full-message (apply #'format (list* nil message args))))
      (cond
        ((string= *last-message* full-message)
         (incf *last-message-repetitions*))
        (t
         (unless (zerop *last-message-repetitions*)
           (do-trace 1 "trace" (format nil "[last message repeated ~a times]"
                                       *last-message-repetitions*))
           (setf *last-message-repetitions* 0))
         (do-trace level (string-downcase *function-name*) full-message)
         (setf *last-message* full-message))))))
#+END_SRC

In C world, one can use [[https://gcc.gnu.org/onlinedocs/gcc/Function-Names.html][~__func__~]] macro to get the name of the current function. CL lacks that feature, so we had to implement it using our own ~defunl~ macro instead of standard ~defun~ for functions we want to see in log.

~defunl~ basically just puts the function name to the dynamic variable ~*function-name*~ right before the function body starts.

#+NAME: defunl
#+BEGIN_SRC lisp
(defvar *function-name* "")

(defmacro defunl (fname lambda-list &body body)
  "DEFUN wrapper which sets correct current function name for logging
functions."
  (let ((docstring (when (stringp (car body)) (pop body))))
    `(defun ,fname ,lambda-list
       ,@(ensure-list docstring)
       (let ((*function-name* (quote ,fname)))
         ,@body))))
#+END_SRC

This variable is being used to supply the function name to ~do-trace~ local function we've seen above, so that the names of Lisp functions can nicely appear in logs like that:

#+BEGIN_EXAMPLE
system      I al_install_system [   0.00000] Allegro version: 5.2.7
d2clone-kit I start-engine      [   0.00027] Starting d2clone-kit engine v0.1.2
d2clone-kit I init-fs           [   0.00031] Appending /home/andrew/Progs/GAMEDEV/d2clone-kit/Resources to mount points
#+END_EXAMPLE

Note that this mechanism might cause slowdown, so you probably don't want the functions called in tight loops to be defined with ~defunl~.

Finally, we don't use the ~%trace~ function itself throughout the engine codebase. Instead, we define a few wrappers for every log severity level supported by liballegro using the ~deflog~ macro, which just defines a small function with docstrings and everything wrapping ~%trace~ with the nice names like ~trace-debug~, ~trace-info~ etc.:

#+NAME: deflog
#+BEGIN_SRC lisp
(defmacro deflog (name level docstring)
  (let
      ((function-name (intern (concatenate 'string "LOG-" (symbol-name name)))))
    `(defun ,function-name (message &rest args)
       ,@(ensure-list docstring)
       (%trace ,level message args))))

(deflog debug 0
  "Adds formatted message MESSAGE using placeholder arguments ARGS to
  liballegro debug channel.")

(deflog info 1
  "Adds formatted message MESSAGE using placeholder arguments ARGS to
  liballegro info channel.")

(deflog warn 2
  "Adds formatted message MESSAGE using placeholder arguments ARGS to
  liballegro warn channel.")

(deflog error 3
  "Adds formatted message MESSAGE using placeholder arguments ARGS to
  liballegro error channel.")
#+END_SRC

** Filesystem

** Config

#+BEGIN_SRC lisp :tangle config.lisp :noweb yes :exports none
<<preamble>>

<<global-config>>

<<init-config>>

<<save-config>>

<<config-setter>>

<<config-getter>>

<<close-config>>

<<defoptions>>

<<system-options>>
#+END_SRC

Config subsystem, while piggybacking on top of [[https://liballeg.org/a5docs/trunk/config.html][liballegro facilities]], provides nice lispy interface to serialize global configuration options. Each of these options have so called /section/, so they're basically organized into simple one-level hierarchy. We'll return to this hierarchy in a moment.

Now first of all, there's global liballegro [[https://liballeg.org/a5docs/trunk/config.html#allegro_config][configuration structure]] called ~*config*~ and used to store everything we need:

#+NAME: global-config
#+BEGIN_SRC lisp
(declaim (type cffi:foreign-pointer *config*))
(global-vars:define-global-var *config* (cffi:null-pointer))
#+END_SRC

~init-log~ function, called in ~run-engine~, just uses [[https://liballeg.org/a5docs/trunk/config.html#al_load_config_file][~al:load-config-file~]] to try and load config from =config.ini= file in data directory. Note that the location of data directory is obtained by liballegro itself using the game name, that's why it is important to call [[https://liballeg.org/a5docs/trunk/system.html#al_set_app_name][~al:set-app-name~]] before calling ~init-log~.
If ~init-log~ fails to load aforementioned file, it just creates an empty configuration structure with the call to [[https://liballeg.org/a5docs/trunk/config.html#al_create_config][~al:create-config~]].

#+NAME: init-config
#+BEGIN_SRC lisp
(defun init-config ()
  (setf *config* (al:load-config-file "config.ini"))
  (when (cffi:null-pointer-p *config*)
    (setf *config* (al:create-config))))
#+END_SRC

There's also an evil twin of ~init-config~, called ~close-config~ and used to finalize config subsystem:

#+NAME: close-config
#+BEGIN_SRC lisp
(defun close-config ()
  (save-config)
  (al:destroy-config *config*)
  (setf *config* (cffi:null-pointer)))
#+END_SRC

It just saves the config with the call to ~save-config~, destroys the global variable ~*config*~ with the call to [[https://liballeg.org/a5docs/trunk/config.html#al_destroy_config][~al:destroy-config~]] and sets it to ~NULL~ pointer to prevent use-after-free memory errors.

~save-config~, in turn, is a simple wrapper over [[https://liballeg.org/a5docs/trunk/config.html#al_save_config_file][~al:save-config-file~]] which just saves configuration data to the file with predefined name =config.ini= (note: it is written by liballegro to the data directory):

#+NAME: save-config
#+BEGIN_SRC lisp
(declaim #-d2c-debug (inline save-config))
(defun save-config ()
  (al:save-config-file "config.ini" *config*))
#+END_SRC

Next, there are two functions which are keystone to config subsystem interface, namely the getter and the setter of options.

The getter, simply called ~config~, first calls [[https://liballeg.org/a5docs/trunk/config.html#al_get_config_value][~al:get-config-value~]] on global ~*config*~ instance to get the configuration option value with supplied section name and option name - both expected to be keywords and both are, of course, converted to string before passing to C API. Note that section could be ~nil~, so that there could be sectionless options.
If the requested value was found, it is being converted to Lisp value with the call to ~read-from-string~, so we can have various Lisp data in config, including, but not limited to lists, for example it is possible to notice something like the following in the config file:

#+BEGIN_EXAMPLE
[DEBUG]
CURSOR=(0 0 255)
#+END_EXAMPLE

which is the list of three elements 0, 0 and 255 in the option named ~:cursor~ under the section named ~:debug~.

If, on the other hand, the requested value was not found, we take the optional default value supplied to the call to ~config~ and set it to configuration calling setter, ~(setf config)~. That's an important feature, and it has two important consequences: (1) while trying to simply get the config option value, there could be underlying disk write to set the previously unset default value, at least for the first time, and (2) even if the config file didn't exist before starting the engine, it would appear afterwards, filled with the default values.

#+NAME: config-getter
#+BEGIN_SRC lisp
(declaim
 (ftype (function ((or keyword null) keyword &optional t) t) config))
(defun config (section key &optional default)
  (if-let (value (al:get-config-value
                  *config* (string (or section :||)) (string key)))
    (read-from-string value)
    (setf (config section key) default)))
#+END_SRC

Now to the option setter, which is being defined as custom ~setf~ place, namely ~(setf config)~. It also takes the option name and optional section name, also converts those to strings and calls [[https://liballeg.org/a5docs/trunk/config.html#al_set_config_value][~al:set-config-value~]] to set the supplied value (converted to the string by the call to ~write-to-string~). After that, it calls ~save-config~ to write updated ~*config*~ structure to disk.

#+NAME: config-setter
#+BEGIN_SRC lisp
(declaim
 (ftype (function (t (or keyword null) keyword) t) (setf config)))
(defun (setf config) (value section key)
  (al:set-config-value
   *config* (string (or section :||)) (string key)
   (write-to-string value))
  (save-config)
  value)
#+END_SRC

Finally, there's a macro called ~defoptions~ used to create a pre-defined set of configuration options along with a nice macro to access those by just specifying their names instead of typing a lot of boilerplate code involving getter and setter described above.
This macro is somewhat similar to the standard ~defstruct~: you specify the name of the set, then you enumerate configuration options, specifically option name, section name, Lisp type and default value, and the macro does the rest. There's nothing more to say about it, except that it involves a bit of semi-complex macro trickery, namely defining a macro within a macro:

#+NAME: defoptions
#+BEGIN_SRC lisp
;; TODO : come up with some sort of caching to global var, calling
;; al_get_config_value is not free
(defmacro defoptions (name &rest options)
  "Defines macro to access given group of options. E.g. when NAME is 'SYSTEM,
it defines WITH-SYSTEM-CONFIG-OPTIONS macro. OPTIONS should be list of lists
containing option's section name, option's name, and :TYPE and :DEFAULT
properties.

See WITH-SYSTEM-CONFIG-OPTIONS"
  (let* ((section-names (mapcar #'car options))
         (key-names (mapcar #'cadr options))
         (option-names (mapcar #'(lambda (s k) (symbolicate s :- k))
                               section-names key-names))
         (option-types (mapcar #'(lambda (o) (getf o :type)) options))
         (option-defaults (mapcar #'(lambda (o) (getf o :default)) options))
         (let-clauses (mapcar
                       #'(lambda (o s k type d)
                           `(,o . ((the ,type
                                        (config ,(make-keyword s)
                                                ,(make-keyword k)
                                                ,d)))))
                       option-names section-names key-names
                       option-types option-defaults)))
    `(defmacro ,(symbolicate :with- name :-config-options) ((options
                                                             &key (read-only t))
                                                            &body body)
       "Executes BODY with bindings for config options OPTIONS. If READ-ONLY is
T (the default), options are not SETF-able."
       (let ((let-clauses
               (remove-if-not
                #'(lambda (c) (find (car c) options))
                '(,@let-clauses))))
         `(,(if read-only 'let 'symbol-macrolet) (,@let-clauses)
           ,@body)))))
#+END_SRC

Let's jump to this macro's usage example, which defines a set of so-called **system config options** used throughout the engine. For now, it just includes two sections: =display=, related to rendering options, and =debug= related to various debugging helpers.

#+NAME: system-options
#+BEGIN_SRC lisp
(defoptions system
  (display width :type fixnum :default 800)
  (display height :type fixnum :default 600)
  (display windowed :type boolean :default t)
  (display vsync :type boolean :default nil)
  (display fps :type boolean :default nil)
  (display multisampling :type fixnum :default 0)
  (display font :type string :default "font.ttf")
  (debug grid :type list :default nil)
  (debug sprite :type list :default nil)
  (debug cursor :type list :default nil)
  (debug path :type list :default nil)
  (debug collisions :type list :default nil)

  )
#+END_SRC

This macro invocation defines the macro ~with-system-config-options~, which is again somewhat similar to standard ~with-slots~ macro in a sense that it allows to write something like this:

#+BEGIN_SRC lisp
(with-system-config-options ((display-width display-height))
  (format t "screen size is ~a x ~a~%" display-width display-height))
#+END_SRC

** Data tables

** ECS

** Events

** Actions

** Renderer

** UI system

# Local Variables:
# org-src-preserve-indentation: t
# End:
